---
globs: *.js,*.css,*.html
description: TravelLog performance optimization guidelines and best practices
---

# ⚡ TravelLog Performance Rules

## 📋 Overview
This document outlines performance optimization guidelines and best practices for the TravelLog project, based on the analyzed codebase structure and mobile-first approach.

## 🚀 Core Performance Principles

### 1. **Mobile-First Optimization** ✅ **IMPLEMENTED**
- ✅ Optimize for mobile devices first
- ✅ Minimize bundle size and loading time
- ✅ Use efficient touch interactions (app.js)
- ✅ Implement proper viewport handling

### 2. **Memory Management** ⚠️ **PARTIALLY IMPLEMENTED**
- ✅ Clean up resources when not needed (basic cleanup)
- ✅ Avoid memory leaks in event listeners (eventListeners array)
- ⚠️ Use efficient data structures (basic implementation)
- ⚠️ Implement proper garbage collection (needs improvement)

### 3. **Rendering Performance** ⚠️ **PARTIALLY IMPLEMENTED**
- ✅ Minimize DOM manipulation (DocumentFragment usage)
- ✅ Use efficient CSS selectors (BEM methodology)
- ❌ Implement virtual scrolling for large lists (not implemented)
- ✅ Optimize animations and transitions (CSS transforms)

### 4. **Network Optimization** ⚠️ **PARTIALLY IMPLEMENTED**
- ✅ Minimize HTTP requests (single CSS import)
- ✅ CSS module separation (travel-report.css → 6 modules)
- ⚠️ Use efficient caching strategies (basic localStorage)
- ⚠️ Implement lazy loading (module-based, not asset-based)
- ⚠️ Optimize asset delivery (needs improvement)

## 📱 Mobile Performance Guidelines

### **Touch Event Optimization** ✅ **IMPLEMENTED in app.js**
```javascript
/**
 * Optimized touch event handling
 * Based on app.js touch optimization - ACTUALLY IMPLEMENTED
 */
(function() {
    'use strict';
    
    let touchStartY = 0;
    let touchStartX = 0;
    let isScrolling = false;
    let scrollTimeout;
    
    // Touch start event
    document.addEventListener('touchstart', function(e) {
        touchStartY = e.touches[0].clientY;
        touchStartX = e.touches[0].clientX;
        isScrolling = false;
        
        clearTimeout(scrollTimeout);
    }, { passive: true });
    
    // Touch move event (prevent horizontal scroll, allow vertical)
    document.addEventListener('touchmove', function(e) {
        const touchY = e.touches[0].clientY;
        const touchX = e.touches[0].clientX;
        const deltaY = Math.abs(touchY - touchStartY);
        const deltaX = Math.abs(touchX - touchStartX);
        
        // Detect vertical scrolling
        if (deltaY > 10) {
            isScrolling = true;
            document.body.classList.add('is-scrolling');
            
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                document.body.classList.remove('is-scrolling');
                isScrolling = false;
            }, 150);
        }
        
        // Prevent horizontal scroll only
        if (deltaX > deltaY && deltaX > 10 && e.cancelable && !isScrolling) {
            e.preventDefault();
        }
    }, { passive: false });
    
    // Prevent double-tap zoom
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(e) {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300 && e.cancelable && !isScrolling) {
            e.preventDefault();
        }
        lastTouchEnd = now;
    }, { passive: false });
})();
```

### **Debouncing Pattern** ✅ **IMPLEMENTED in SearchTab.js**
```javascript
/**
 * Debouncing pattern used in SearchTab.js
 * ACTUALLY IMPLEMENTED with 300ms delay
 */
class SearchTab {
    constructor() {
        this.searchTimeout = null;
        this.debounceDelay = 300; // 300ms debounce
    }
    
    handleSearchInput(event) {
        const query = event.target.value;
        
        // Clear previous timeout
        if (this.searchTimeout) {
            clearTimeout(this.searchTimeout);
        }
        
        // Set new timeout
        this.searchTimeout = setTimeout(() => {
            this.performSearch(query);
        }, this.debounceDelay);
    }
}
```

### **Viewport and Layout Optimization**
```css
/* Mobile viewport optimization */
* {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}

/* Input fields allow text selection */
input, textarea {
    -webkit-user-select: text;
    -khtml-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
    user-select: text;
}

/* Touch action optimization */
button, .tab-btn, .login-btn, .demo-btn {
    touch-action: manipulation;
}

/* Prevent zoom on input focus */
.form-input {
    touch-action: manipulation;
    font-size: 16px; /* iOS zoom prevention */
}

/* Minimum touch target size */
@media (max-width: 768px) {
    button, .tab-btn, .login-btn, .demo-btn {
        min-height: 44px; /* iOS recommended minimum */
        min-width: 44px;
    }
    
    .form-input {
        min-height: 44px;
    }
}
```

## 🎨 CSS Performance Optimization

### **Efficient CSS Selectors**
```css
/* ✅ Good - Simple selectors */
.travel-card { }
.travel-card__header { }
.travel-card--featured { }

/* ❌ Avoid - Complex selectors */
div.travel-card .header .title span { }
.travel-card .header .title:first-child span:last-child { }

/* ✅ Good - Class-based targeting */
.navigation .tab-btn.active { }

/* ❌ Avoid - Descendant selectors */
.navigation .tab-btn .tab-icon .tab-label { }
```

### **CSS Animation Performance**
```css
/* ✅ Good - Use transform and opacity */
.animate {
    transform: translateY(0);
    opacity: 1;
    transition: transform var(--transition-normal), opacity var(--transition-normal);
}

.animate:hover {
    transform: translateY(-2px);
    opacity: 0.9;
}

/* ❌ Avoid - Expensive properties */
.animate:hover {
    top: -2px; /* Triggers layout */
    left: 0;   /* Triggers layout */
    width: 100px; /* Triggers layout */
    height: 50px; /* Triggers layout */
}

/* ✅ Good - GPU acceleration */
.gpu-accelerated {
    transform: translate3d(0, 0, 0);
    backface-visibility: hidden;
    perspective: 1000px;
}
```

### **CSS Optimization Techniques**
```css
/* Use CSS variables for consistency */
:root {
    --primary-color: #667eea;
    --spacing-md: 16px;
    --border-radius-md: 10px;
}

/* Avoid repeated calculations */
.component {
    padding: var(--spacing-md);
    margin: var(--spacing-md);
    border-radius: var(--border-radius-md);
}

/* Use efficient box model */
.component {
    box-sizing: border-box;
    width: 100%;
    padding: var(--spacing-md);
    border: 1px solid var(--gray-300);
}

/* Optimize for mobile */
@media (max-width: 768px) {
    .component {
        padding: var(--spacing-sm);
        font-size: var(--font-sm);
    }
}
```

### **CSS Module Performance Benefits**
```css
/* Module separation performance gains */
/* Before: travel-report.css (1336 lines) */
/* After: 6 modules (average 200 lines each) */

/* Benefits: */
/* 1. Faster file loading and editing */
/* 2. Reduced merge conflicts in team collaboration */
/* 3. Better browser caching (smaller files) */
/* 4. Easier maintenance and debugging */
/* 5. Future lazy loading preparation */
```

## 🧩 JavaScript Performance Optimization

### **DOM Manipulation Optimization**
```javascript
/**
 * Efficient DOM manipulation
 */
class DOMOptimizer {
    constructor() {
        this.fragment = document.createDocumentFragment();
        this.cache = new Map();
    }
    
    /**
     * Batch DOM updates using DocumentFragment
     */
    batchUpdate(container, elements) {
        // Clear fragment
        while (this.fragment.firstChild) {
            this.fragment.removeChild(this.fragment.firstChild);
        }
        
        // Add elements to fragment
        elements.forEach(element => {
            this.fragment.appendChild(element);
        });
        
        // Single DOM update
        container.appendChild(this.fragment);
    }
    
    /**
     * Cache DOM queries
     */
    querySelector(selector) {
        if (!this.cache.has(selector)) {
            this.cache.set(selector, document.querySelector(selector));
        }
        return this.cache.get(selector);
    }
    
    /**
     * Use requestAnimationFrame for smooth animations
     */
    animate(element, callback) {
        requestAnimationFrame(() => {
            callback(element);
        });
    }
}
```

### **Event Handling Optimization**
```javascript
/**
 * Optimized event handling
 */
class EventOptimizer {
    constructor() {
        this.debounceTimers = new Map();
        this.throttleTimers = new Map();
    }
    
    /**
     * Debounce function calls
     */
    debounce(func, wait, key = 'default') {
        return (...args) => {
            clearTimeout(this.debounceTimers.get(key));
            this.debounceTimers.set(key, setTimeout(() => {
                func.apply(this, args);
            }, wait));
        };
    }
    
    /**
     * Throttle function calls
     */
    throttle(func, limit, key = 'default') {
        return (...args) => {
            if (!this.throttleTimers.has(key)) {
                func.apply(this, args);
                this.throttleTimers.set(key, true);
                setTimeout(() => {
                    this.throttleTimers.delete(key);
                }, limit);
            }
        };
    }
    
    /**
     * Event delegation for dynamic content
     */
    delegate(container, selector, event, handler) {
        container.addEventListener(event, (e) => {
            if (e.target.matches(selector)) {
                handler(e);
            }
        });
    }
}
```

### **Memory Management**
```javascript
/**
 * Memory management utilities
 */
class MemoryManager {
    constructor() {
        this.cleanupTasks = [];
        this.weakRefs = new WeakMap();
    }
    
    /**
     * Register cleanup task
     */
    registerCleanup(task) {
        this.cleanupTasks.push(task);
    }
    
    /**
     * Execute all cleanup tasks
     */
    cleanup() {
        this.cleanupTasks.forEach(task => {
            try {
                task();
            } catch (error) {
                console.error('Cleanup task failed:', error);
            }
        });
        this.cleanupTasks = [];
    }
    
    /**
     * Create weak reference
     */
    createWeakRef(object) {
        return new WeakRef(object);
    }
    
    /**
     * Check if weak reference is still valid
     */
    isWeakRefValid(weakRef) {
        return weakRef.deref() !== undefined;
    }
}
```

## 📊 Data Management Performance

### **Efficient Data Structures**
```javascript
/**
 * Optimized data management
 */
class DataManager {
    constructor() {
        this.cache = new Map();
        this.indexes = new Map();
        this.maxCacheSize = 100;
    }
    
    /**
     * Efficient data retrieval with indexing
     */
    getData(key, indexKey = null) {
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        
        // Load from storage
        const data = this.loadFromStorage(key);
        
        // Cache with size limit
        if (this.cache.size >= this.maxCacheSize) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        
        this.cache.set(key, data);
        
        // Create index if specified
        if (indexKey) {
            this.createIndex(data, indexKey);
        }
        
        return data;
    }
    
    /**
     * Create search index
     */
    createIndex(data, key) {
        const index = new Map();
        data.forEach((item, i) => {
            const value = item[key];
            if (!index.has(value)) {
                index.set(value, []);
            }
            index.get(value).push(i);
        });
        this.indexes.set(key, index);
    }
    
    /**
     * Fast search using index
     */
    search(key, searchKey, value) {
        const index = this.indexes.get(searchKey);
        if (index && index.has(value)) {
            const indices = index.get(value);
            const data = this.cache.get(key);
            return indices.map(i => data[i]);
        }
        return [];
    }
}
```

### **Lazy Loading Implementation**
```javascript
/**
 * Lazy loading for modules and data
 */
class LazyLoader {
    constructor() {
        this.loadedModules = new Map();
        this.loadingPromises = new Map();
    }
    
    /**
     * Lazy load module
     */
    async loadModule(modulePath) {
        if (this.loadedModules.has(modulePath)) {
            return this.loadedModules.get(modulePath);
        }
        
        if (this.loadingPromises.has(modulePath)) {
            return this.loadingPromises.get(modulePath);
        }
        
        const promise = this._loadModule(modulePath);
        this.loadingPromises.set(modulePath, promise);
        
        try {
            const module = await promise;
            this.loadedModules.set(modulePath, module);
            this.loadingPromises.delete(modulePath);
            return module;
        } catch (error) {
            this.loadingPromises.delete(modulePath);
            throw error;
        }
    }
    
    async _loadModule(modulePath) {
        const module = await import(modulePath);
        return module.default || module;
    }
}
```

## 🎯 Rendering Performance

### **Advanced Rendering Patterns**

> **Note**: Virtual scrolling and canvas optimization are advanced patterns that are not currently needed in TravelLog. These patterns can be implemented when dealing with large datasets or complex visualizations in the future.

## 🔧 Network Performance

### **Resource Optimization**
```javascript
/**
 * Resource loading optimization
 */
class ResourceOptimizer {
    constructor() {
        this.loadedResources = new Set();
        this.loadingPromises = new Map();
    }
    
    /**
     * Preload critical resources
     */
    async preloadCritical() {
        const criticalResources = [
            'styles/main.css',
            'js/app.js',
            'js/config/app-config.js'
        ];
        
        const promises = criticalResources.map(resource => 
            this.loadResource(resource)
        );
        
        await Promise.all(promises);
    }
    
    /**
     * Load resource with caching
     */
    async loadResource(url) {
        if (this.loadedResources.has(url)) {
            return;
        }
        
        if (this.loadingPromises.has(url)) {
            return this.loadingPromises.get(url);
        }
        
        const promise = this._loadResource(url);
        this.loadingPromises.set(url, promise);
        
        try {
            await promise;
            this.loadedResources.add(url);
            this.loadingPromises.delete(url);
        } catch (error) {
            this.loadingPromises.delete(url);
            throw error;
        }
    }
    
    async _loadResource(url) {
        if (url.endsWith('.css')) {
            return this.loadCSS(url);
        } else if (url.endsWith('.js')) {
            return this.loadJS(url);
        } else {
            return this.loadImage(url);
        }
    }
}
```

## 📊 Performance Monitoring

### **Basic Performance Monitoring**
```javascript
/**
 * Simple performance monitoring for development
 */
class BasicPerformanceMonitor {
    /**
     * Measure function execution time
     */
    static measure(name, fn) {
        const start = performance.now();
        const result = fn();
        const end = performance.now();
        
        console.log(`${name}: ${(end - start).toFixed(2)}ms`);
        return result;
    }
    
    /**
     * Check memory usage (if available)
     */
    static getMemoryUsage() {
        if (performance.memory) {
            return {
                used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',
                total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB'
            };
        }
        return null;
    }
}
```

## 🚀 Best Practices Summary

### **Performance Checklist** (Based on actual implementation status)

#### ✅ **IMPLEMENTED**
- ✅ Optimize for mobile devices first
- ✅ Use efficient CSS selectors (BEM methodology)
- ✅ Minimize DOM manipulation (DocumentFragment usage)
- ✅ Clean up resources properly (eventListeners array)
- ✅ Use debouncing for search (300ms delay)
- ✅ Optimize touch interactions (app.js)
- ✅ Use CSS transforms for animations
- ✅ CSS module separation (travel-report.css → 6 modules)

#### ⚠️ **PARTIALLY IMPLEMENTED**
- ⚠️ Implement proper caching (basic localStorage only)
- ⚠️ Use lazy loading for non-critical resources (module-based)
- ⚠️ Use event delegation for dynamic content (some modules)

#### ❌ **NOT IMPLEMENTED** (Future improvements)
- ❌ Advanced performance monitoring
- ❌ Advanced caching strategies
- ❌ Asset optimization

### **Current Implementation Status**

#### **Mobile Performance** ✅ **EXCELLENT**
- Touch event optimization fully implemented
- Viewport handling properly configured
- Mobile-first CSS approach
- Touch-friendly UI elements

#### **Memory Management** ⚠️ **GOOD**
- Basic cleanup implemented
- Event listener tracking
- Timeout management
- Needs improvement for complex modules

#### **Rendering Performance** ⚠️ **GOOD**
- Efficient CSS selectors
- CSS transforms for animations
- Basic DOM optimization
- Missing virtual scrolling

#### **Network Performance** ⚠️ **BASIC**
- Single CSS bundle
- Basic module loading
- Missing advanced caching
- Missing asset optimization

### **API Integration Performance Guidelines** ⭐ **NEW**

#### **API Call Optimization**
```javascript
/**
 * Optimized API service for performance
 */
class OptimizedAPIService {
    constructor(config) {
        this.baseURL = config.baseURL;
        this.timeout = config.timeout || 10000;
        this.retryAttempts = config.retryAttempts || 3;
        this.cache = new Map();
        this.cacheTimeout = config.cacheTimeout || 5 * 60 * 1000; // 5 minutes
        this.requestQueue = new Map(); // Prevent duplicate requests
    }
    
    /**
     * Optimized API call with caching and deduplication
     */
    async callAPI(endpoint, options = {}) {
        const cacheKey = this.generateCacheKey(endpoint, options);
        
        // Check cache first
        if (this.cache.has(cacheKey)) {
            const cached = this.cache.get(cacheKey);
            if (Date.now() - cached.timestamp < this.cacheTimeout) {
                return cached.data;
            }
        }
        
        // Check if request is already in progress
        if (this.requestQueue.has(cacheKey)) {
            return this.requestQueue.get(cacheKey);
        }
        
        // Create new request promise
        const requestPromise = this.executeRequest(endpoint, options);
        this.requestQueue.set(cacheKey, requestPromise);
        
        try {
            const data = await requestPromise;
            
            // Cache successful response
            this.cache.set(cacheKey, {
                data,
                timestamp: Date.now()
            });
            
            return data;
        } finally {
            // Remove from queue
            this.requestQueue.delete(cacheKey);
        }
    }
    
    /**
     * Execute request with retry logic
     */
    async executeRequest(endpoint, options) {
        for (let attempt = 1; attempt <= this.retryAttempts; attempt++) {
            try {
                const response = await this.makeRequest(endpoint, options);
                return response;
            } catch (error) {
                if (attempt === this.retryAttempts) {
                    throw error;
                }
                
                // Exponential backoff
                await this.delay(Math.pow(2, attempt) * 1000);
            }
        }
    }
    
    /**
     * Make HTTP request with timeout
     */
    async makeRequest(endpoint, options) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);
        
        try {
            const response = await fetch(`${this.baseURL}${endpoint}`, {
                ...options,
                signal: controller.signal,
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    ...options.headers
                }
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`API 응답 오류: ${response.status} ${response.statusText}`);
            }
            
            const data = await response.json();
            return data;
        } catch (error) {
            clearTimeout(timeoutId);
            throw error;
        }
    }
    
    /**
     * Generate cache key for request
     */
    generateCacheKey(endpoint, options) {
        return `${endpoint}_${JSON.stringify(options)}`;
    }
    
    /**
     * Delay utility for retry logic
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    /**
     * Clear expired cache entries
     */
    clearExpiredCache() {
        const now = Date.now();
        for (const [key, value] of this.cache.entries()) {
            if (now - value.timestamp > this.cacheTimeout) {
                this.cache.delete(key);
            }
        }
    }
}
```

#### **API Performance Best Practices**
```javascript
// ✅ Good - Efficient API data management
class OptimizedAPIDataManager {
    constructor(apiService, fallbackData) {
        this.apiService = apiService;
        this.fallbackData = fallbackData;
        this.isOnline = navigator.onLine;
        this.dataCache = new Map();
        
        // Monitor online status
        window.addEventListener('online', () => {
            this.isOnline = true;
            this.clearCache();
        });
        
        window.addEventListener('offline', () => {
            this.isOnline = false;
        });
        
        // Clear expired cache periodically
        setInterval(() => {
            this.apiService.clearExpiredCache();
        }, 60000); // Every minute
    }
    
    // Batch multiple API calls
    async batchAPICalls(requests) {
        const promises = requests.map(request => 
            this.apiService.callAPI(request.endpoint, request.options)
        );
        
        try {
            const results = await Promise.allSettled(promises);
            return results.map((result, index) => ({
                request: requests[index],
                success: result.status === 'fulfilled',
                data: result.status === 'fulfilled' ? result.value : null,
                error: result.status === 'rejected' ? result.reason : null
            }));
        } catch (error) {
            console.error('Batch API calls failed:', error);
            throw error;
        }
    }
    
    // Preload critical data
    async preloadCriticalData(keys) {
        const preloadPromises = keys.map(key => 
            this.getData(key, () => this.apiService.callAPI(`/data/${key}`))
        );
        
        try {
            await Promise.allSettled(preloadPromises);
            console.log('Critical data preloaded successfully');
        } catch (error) {
            console.warn('Some critical data failed to preload:', error);
        }
    }
}

// ✅ Good - Optimized API component rendering
class OptimizedAPIIntegratedComponent {
    constructor(container, dataManager, options = {}) {
        this.container = container;
        this.dataManager = dataManager;
        this.options = {
            placeholder: '검색하세요...',
            maxResults: 50,
            showLoading: true,
            debounceDelay: 300,
            ...options
        };
        
        this.isLoading = false;
        this.data = [];
        this.filteredData = [];
        this.eventListeners = new Map();
        this.renderQueue = [];
        this.isRendering = false;
        
        // Debounced search
        this.debouncedSearch = this.debounce(this.search.bind(this), this.options.debounceDelay);
    }
    
    // Debounce search to prevent excessive API calls
    debounce(func, wait) {
        let timeoutId;
        return (...args) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func.apply(this, args), wait);
        };
    }
    
    // Batch UI updates to prevent excessive reflows
    batchRender(renderFunction) {
        this.renderQueue.push(renderFunction);
        
        if (!this.isRendering) {
            this.isRendering = true;
            requestAnimationFrame(() => {
                this.processRenderQueue();
                this.isRendering = false;
            });
        }
    }
    
    processRenderQueue() {
        while (this.renderQueue.length > 0) {
            const render = this.renderQueue.shift();
            render();
        }
    }
}
```

#### **API Performance Checklist**
- ✅ Implement request caching to reduce API calls
- ✅ Use request deduplication to prevent duplicate calls
- ✅ Implement exponential backoff for retry logic
- ✅ Batch multiple API calls when possible
- ✅ Preload critical data for better user experience
- ✅ Use debouncing for search and input operations
- ✅ Implement proper error handling and fallback systems
- ✅ Monitor online/offline status for graceful degradation
- ✅ Clear expired cache entries periodically
- ✅ Use requestAnimationFrame for smooth UI updates

### **Authentication Performance Guidelines** ⭐ **NEW**

#### **Session Management Optimization**
```javascript
/**
 * Optimized session management for authentication
 */
class AuthPerformanceOptimizer {
    constructor() {
        this.sessionCache = new Map();
        this.authStateCache = null;
        this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
    }
    
    /**
     * Cache session data to reduce API calls
     */
    cacheSession(session) {
        this.authStateCache = {
            session,
            timestamp: Date.now()
        };
    }
    
    /**
     * Get cached session if still valid
     */
    getCachedSession() {
        if (!this.authStateCache) return null;
        
        const isExpired = Date.now() - this.authStateCache.timestamp > this.cacheTimeout;
        if (isExpired) {
            this.authStateCache = null;
            return null;
        }
        
        return this.authStateCache.session;
    }
    
    /**
     * Debounce authentication state changes
     */
    debounceAuthStateChange(callback, delay = 300) {
        let timeoutId;
        return (...args) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => callback.apply(this, args), delay);
        };
    }
}
```

#### **Authentication Performance Best Practices**
```javascript
// ✅ Good - Efficient authentication state management
class OptimizedAuthService {
    constructor() {
        this.authStateListeners = [];
        this.debouncedStateChange = this.debounceAuthStateChange(
            this.notifyListeners.bind(this), 
            100
        );
    }
    
    // Debounce state changes to prevent excessive UI updates
    debounceAuthStateChange(callback, delay) {
        let timeoutId;
        return (...args) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => callback.apply(this, args), delay);
        };
    }
    
    // Cache user data to reduce API calls
    async getCurrentUser() {
        if (this.cachedUser && this.isCacheValid()) {
            return this.cachedUser;
        }
        
        const user = await this.fetchUserFromAPI();
        this.cachedUser = user;
        this.cacheTimestamp = Date.now();
        return user;
    }
}

// ✅ Good - Optimized authentication UI updates
class OptimizedAuthManager {
    constructor() {
        this.updateQueue = [];
        this.isUpdating = false;
    }
    
    // Batch UI updates to prevent excessive reflows
    batchUIUpdate(updateFunction) {
        this.updateQueue.push(updateFunction);
        
        if (!this.isUpdating) {
            this.isUpdating = true;
            requestAnimationFrame(() => {
                this.processUpdateQueue();
                this.isUpdating = false;
            });
        }
    }
    
    processUpdateQueue() {
        while (this.updateQueue.length > 0) {
            const update = this.updateQueue.shift();
            update();
        }
    }
}
```

#### **Authentication Performance Checklist**
- ✅ Cache authentication state to reduce API calls
- ✅ Debounce authentication state changes
- ✅ Batch UI updates during authentication flows
- ✅ Use requestAnimationFrame for smooth transitions
- ✅ Implement proper session cleanup
- ✅ Optimize authentication form validation
- ✅ Use efficient error handling patterns

### **Common Performance Pitfalls**
❌ Don't use expensive CSS properties in animations
❌ Don't manipulate DOM in tight loops
❌ Don't ignore memory leaks
❌ Don't load all resources at once
❌ Don't use complex CSS selectors
❌ Don't ignore mobile performance
❌ Don't skip resource cleanup
❌ Don't use synchronous operations
❌ Don't ignore bundle size
❌ Don't skip performance testing
❌ Don't ignore authentication performance optimization ⭐ **NEW**
❌ Don't skip authentication state caching ⭐ **NEW**
❌ Don't ignore authentication UI update batching ⭐ **NEW**