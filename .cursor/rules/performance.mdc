---
globs: *.js,*.css,*.html
description: TravelLog performance optimization guidelines and best practices
---

# âš¡ TravelLog Performance Rules

## ğŸ“‹ Overview
This document outlines performance optimization guidelines and best practices for the TravelLog project, based on the analyzed codebase structure and mobile-first approach.

## ğŸš€ Core Performance Principles

### 1. **Mobile-First Optimization** âœ… **IMPLEMENTED**
- âœ… Optimize for mobile devices first
- âœ… Minimize bundle size and loading time
- âœ… Use efficient touch interactions (app.js)
- âœ… Implement proper viewport handling

### 2. **Memory Management** âš ï¸ **PARTIALLY IMPLEMENTED**
- âœ… Clean up resources when not needed (basic cleanup)
- âœ… Avoid memory leaks in event listeners (eventListeners array)
- âš ï¸ Use efficient data structures (basic implementation)
- âš ï¸ Implement proper garbage collection (needs improvement)

### 3. **Rendering Performance** âš ï¸ **PARTIALLY IMPLEMENTED**
- âœ… Minimize DOM manipulation (DocumentFragment usage)
- âœ… Use efficient CSS selectors (BEM methodology)
- âŒ Implement virtual scrolling for large lists (not implemented)
- âœ… Optimize animations and transitions (CSS transforms)

### 4. **Network Optimization** âš ï¸ **PARTIALLY IMPLEMENTED**
- âœ… Minimize HTTP requests (single CSS import)
- âœ… CSS module separation (travel-report.css â†’ 6 modules)
- âš ï¸ Use efficient caching strategies (basic localStorage)
- âš ï¸ Implement lazy loading (module-based, not asset-based)
- âš ï¸ Optimize asset delivery (needs improvement)

## ğŸ“± Mobile Performance Guidelines

### **Touch Event Optimization** âœ… **IMPLEMENTED in app.js**
```javascript
/**
 * Optimized touch event handling
 * Based on app.js touch optimization - ACTUALLY IMPLEMENTED
 */
(function() {
    'use strict';
    
    let touchStartY = 0;
    let touchStartX = 0;
    let isScrolling = false;
    let scrollTimeout;
    
    // Touch start event
    document.addEventListener('touchstart', function(e) {
        touchStartY = e.touches[0].clientY;
        touchStartX = e.touches[0].clientX;
        isScrolling = false;
        
        clearTimeout(scrollTimeout);
    }, { passive: true });
    
    // Touch move event (prevent horizontal scroll, allow vertical)
    document.addEventListener('touchmove', function(e) {
        const touchY = e.touches[0].clientY;
        const touchX = e.touches[0].clientX;
        const deltaY = Math.abs(touchY - touchStartY);
        const deltaX = Math.abs(touchX - touchStartX);
        
        // Detect vertical scrolling
        if (deltaY > 10) {
            isScrolling = true;
            document.body.classList.add('is-scrolling');
            
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                document.body.classList.remove('is-scrolling');
                isScrolling = false;
            }, 150);
        }
        
        // Prevent horizontal scroll only
        if (deltaX > deltaY && deltaX > 10 && e.cancelable && !isScrolling) {
            e.preventDefault();
        }
    }, { passive: false });
    
    // Prevent double-tap zoom
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(e) {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300 && e.cancelable && !isScrolling) {
            e.preventDefault();
        }
        lastTouchEnd = now;
    }, { passive: false });
})();
```

### **Debouncing Pattern** âœ… **IMPLEMENTED in SearchTab.js**
```javascript
/**
 * Debouncing pattern used in SearchTab.js
 * ACTUALLY IMPLEMENTED with 300ms delay
 */
class SearchTab {
    constructor() {
        this.searchTimeout = null;
        this.debounceDelay = 300; // 300ms debounce
    }
    
    handleSearchInput(event) {
        const query = event.target.value;
        
        // Clear previous timeout
        if (this.searchTimeout) {
            clearTimeout(this.searchTimeout);
        }
        
        // Set new timeout
        this.searchTimeout = setTimeout(() => {
            this.performSearch(query);
        }, this.debounceDelay);
    }
}
```

### **Viewport and Layout Optimization**
```css
/* Mobile viewport optimization */
* {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}

/* Input fields allow text selection */
input, textarea {
    -webkit-user-select: text;
    -khtml-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
    user-select: text;
}

/* Touch action optimization */
button, .tab-btn, .login-btn, .demo-btn {
    touch-action: manipulation;
}

/* Prevent zoom on input focus */
.form-input {
    touch-action: manipulation;
    font-size: 16px; /* iOS zoom prevention */
}

/* Minimum touch target size */
@media (max-width: 768px) {
    button, .tab-btn, .login-btn, .demo-btn {
        min-height: 44px; /* iOS recommended minimum */
        min-width: 44px;
    }
    
    .form-input {
        min-height: 44px;
    }
}
```

## ğŸ¨ CSS Performance Optimization

### **Efficient CSS Selectors**
```css
/* âœ… Good - Simple selectors */
.travel-card { }
.travel-card__header { }
.travel-card--featured { }

/* âŒ Avoid - Complex selectors */
div.travel-card .header .title span { }
.travel-card .header .title:first-child span:last-child { }

/* âœ… Good - Class-based targeting */
.navigation .tab-btn.active { }

/* âŒ Avoid - Descendant selectors */
.navigation .tab-btn .tab-icon .tab-label { }
```

### **CSS Animation Performance**
```css
/* âœ… Good - Use transform and opacity */
.animate {
    transform: translateY(0);
    opacity: 1;
    transition: transform var(--transition-normal), opacity var(--transition-normal);
}

.animate:hover {
    transform: translateY(-2px);
    opacity: 0.9;
}

/* âŒ Avoid - Expensive properties */
.animate:hover {
    top: -2px; /* Triggers layout */
    left: 0;   /* Triggers layout */
    width: 100px; /* Triggers layout */
    height: 50px; /* Triggers layout */
}

/* âœ… Good - GPU acceleration */
.gpu-accelerated {
    transform: translate3d(0, 0, 0);
    backface-visibility: hidden;
    perspective: 1000px;
}
```

### **CSS Optimization Techniques**
```css
/* Use CSS variables for consistency */
:root {
    --primary-color: #667eea;
    --spacing-md: 16px;
    --border-radius-md: 10px;
}

/* Avoid repeated calculations */
.component {
    padding: var(--spacing-md);
    margin: var(--spacing-md);
    border-radius: var(--border-radius-md);
}

/* Use efficient box model */
.component {
    box-sizing: border-box;
    width: 100%;
    padding: var(--spacing-md);
    border: 1px solid var(--gray-300);
}

/* Optimize for mobile */
@media (max-width: 768px) {
    .component {
        padding: var(--spacing-sm);
        font-size: var(--font-sm);
    }
}
```

### **CSS Module Performance Benefits**
```css
/* Module separation performance gains */
/* Before: travel-report.css (1336 lines) */
/* After: 6 modules (average 200 lines each) */

/* Benefits: */
/* 1. Faster file loading and editing */
/* 2. Reduced merge conflicts in team collaboration */
/* 3. Better browser caching (smaller files) */
/* 4. Easier maintenance and debugging */
/* 5. Future lazy loading preparation */
```

## ğŸ§© JavaScript Performance Optimization

### **DOM Manipulation Optimization**
```javascript
/**
 * Efficient DOM manipulation
 */
class DOMOptimizer {
    constructor() {
        this.fragment = document.createDocumentFragment();
        this.cache = new Map();
    }
    
    /**
     * Batch DOM updates using DocumentFragment
     */
    batchUpdate(container, elements) {
        // Clear fragment
        while (this.fragment.firstChild) {
            this.fragment.removeChild(this.fragment.firstChild);
        }
        
        // Add elements to fragment
        elements.forEach(element => {
            this.fragment.appendChild(element);
        });
        
        // Single DOM update
        container.appendChild(this.fragment);
    }
    
    /**
     * Cache DOM queries
     */
    querySelector(selector) {
        if (!this.cache.has(selector)) {
            this.cache.set(selector, document.querySelector(selector));
        }
        return this.cache.get(selector);
    }
    
    /**
     * Use requestAnimationFrame for smooth animations
     */
    animate(element, callback) {
        requestAnimationFrame(() => {
            callback(element);
        });
    }
}
```

### **Event Handling Optimization**
```javascript
/**
 * Optimized event handling
 */
class EventOptimizer {
    constructor() {
        this.debounceTimers = new Map();
        this.throttleTimers = new Map();
    }
    
    /**
     * Debounce function calls
     */
    debounce(func, wait, key = 'default') {
        return (...args) => {
            clearTimeout(this.debounceTimers.get(key));
            this.debounceTimers.set(key, setTimeout(() => {
                func.apply(this, args);
            }, wait));
        };
    }
    
    /**
     * Throttle function calls
     */
    throttle(func, limit, key = 'default') {
        return (...args) => {
            if (!this.throttleTimers.has(key)) {
                func.apply(this, args);
                this.throttleTimers.set(key, true);
                setTimeout(() => {
                    this.throttleTimers.delete(key);
                }, limit);
            }
        };
    }
    
    /**
     * Event delegation for dynamic content
     */
    delegate(container, selector, event, handler) {
        container.addEventListener(event, (e) => {
            if (e.target.matches(selector)) {
                handler(e);
            }
        });
    }
}
```

### **Memory Management**
```javascript
/**
 * Memory management utilities
 */
class MemoryManager {
    constructor() {
        this.cleanupTasks = [];
        this.weakRefs = new WeakMap();
    }
    
    /**
     * Register cleanup task
     */
    registerCleanup(task) {
        this.cleanupTasks.push(task);
    }
    
    /**
     * Execute all cleanup tasks
     */
    cleanup() {
        this.cleanupTasks.forEach(task => {
            try {
                task();
            } catch (error) {
                console.error('Cleanup task failed:', error);
            }
        });
        this.cleanupTasks = [];
    }
    
    /**
     * Create weak reference
     */
    createWeakRef(object) {
        return new WeakRef(object);
    }
    
    /**
     * Check if weak reference is still valid
     */
    isWeakRefValid(weakRef) {
        return weakRef.deref() !== undefined;
    }
}
```

## ğŸ“Š Data Management Performance

### **Efficient Data Structures**
```javascript
/**
 * Optimized data management
 */
class DataManager {
    constructor() {
        this.cache = new Map();
        this.indexes = new Map();
        this.maxCacheSize = 100;
    }
    
    /**
     * Efficient data retrieval with indexing
     */
    getData(key, indexKey = null) {
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        
        // Load from storage
        const data = this.loadFromStorage(key);
        
        // Cache with size limit
        if (this.cache.size >= this.maxCacheSize) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        
        this.cache.set(key, data);
        
        // Create index if specified
        if (indexKey) {
            this.createIndex(data, indexKey);
        }
        
        return data;
    }
    
    /**
     * Create search index
     */
    createIndex(data, key) {
        const index = new Map();
        data.forEach((item, i) => {
            const value = item[key];
            if (!index.has(value)) {
                index.set(value, []);
            }
            index.get(value).push(i);
        });
        this.indexes.set(key, index);
    }
    
    /**
     * Fast search using index
     */
    search(key, searchKey, value) {
        const index = this.indexes.get(searchKey);
        if (index && index.has(value)) {
            const indices = index.get(value);
            const data = this.cache.get(key);
            return indices.map(i => data[i]);
        }
        return [];
    }
}
```

### **Lazy Loading Implementation**
```javascript
/**
 * Lazy loading for modules and data
 */
class LazyLoader {
    constructor() {
        this.loadedModules = new Map();
        this.loadingPromises = new Map();
    }
    
    /**
     * Lazy load module
     */
    async loadModule(modulePath) {
        if (this.loadedModules.has(modulePath)) {
            return this.loadedModules.get(modulePath);
        }
        
        if (this.loadingPromises.has(modulePath)) {
            return this.loadingPromises.get(modulePath);
        }
        
        const promise = this._loadModule(modulePath);
        this.loadingPromises.set(modulePath, promise);
        
        try {
            const module = await promise;
            this.loadedModules.set(modulePath, module);
            this.loadingPromises.delete(modulePath);
            return module;
        } catch (error) {
            this.loadingPromises.delete(modulePath);
            throw error;
        }
    }
    
    async _loadModule(modulePath) {
        const module = await import(modulePath);
        return module.default || module;
    }
}
```

## ğŸ¯ Rendering Performance

### **Advanced Rendering Patterns**

> **Note**: Virtual scrolling and canvas optimization are advanced patterns that are not currently needed in TravelLog. These patterns can be implemented when dealing with large datasets or complex visualizations in the future.

## ğŸ”§ Network Performance

### **Resource Optimization**
```javascript
/**
 * Resource loading optimization
 */
class ResourceOptimizer {
    constructor() {
        this.loadedResources = new Set();
        this.loadingPromises = new Map();
    }
    
    /**
     * Preload critical resources
     */
    async preloadCritical() {
        const criticalResources = [
            'styles/main.css',
            'js/app.js',
            'js/config/app-config.js'
        ];
        
        const promises = criticalResources.map(resource => 
            this.loadResource(resource)
        );
        
        await Promise.all(promises);
    }
    
    /**
     * Load resource with caching
     */
    async loadResource(url) {
        if (this.loadedResources.has(url)) {
            return;
        }
        
        if (this.loadingPromises.has(url)) {
            return this.loadingPromises.get(url);
        }
        
        const promise = this._loadResource(url);
        this.loadingPromises.set(url, promise);
        
        try {
            await promise;
            this.loadedResources.add(url);
            this.loadingPromises.delete(url);
        } catch (error) {
            this.loadingPromises.delete(url);
            throw error;
        }
    }
    
    async _loadResource(url) {
        if (url.endsWith('.css')) {
            return this.loadCSS(url);
        } else if (url.endsWith('.js')) {
            return this.loadJS(url);
        } else {
            return this.loadImage(url);
        }
    }
}
```

## ğŸ“Š Performance Monitoring

### **Basic Performance Monitoring**
```javascript
/**
 * Simple performance monitoring for development
 */
class BasicPerformanceMonitor {
    /**
     * Measure function execution time
     */
    static measure(name, fn) {
        const start = performance.now();
        const result = fn();
        const end = performance.now();
        
        console.log(`${name}: ${(end - start).toFixed(2)}ms`);
        return result;
    }
    
    /**
     * Check memory usage (if available)
     */
    static getMemoryUsage() {
        if (performance.memory) {
            return {
                used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',
                total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB'
            };
        }
        return null;
    }
}
```

## ğŸš€ Best Practices Summary

### **Performance Checklist** (Based on actual implementation status)

#### âœ… **IMPLEMENTED**
- âœ… Optimize for mobile devices first
- âœ… Use efficient CSS selectors (BEM methodology)
- âœ… Minimize DOM manipulation (DocumentFragment usage)
- âœ… Clean up resources properly (eventListeners array)
- âœ… Use debouncing for search (300ms delay)
- âœ… Optimize touch interactions (app.js)
- âœ… Use CSS transforms for animations
- âœ… CSS module separation (travel-report.css â†’ 6 modules)

#### âš ï¸ **PARTIALLY IMPLEMENTED**
- âš ï¸ Implement proper caching (basic localStorage only)
- âš ï¸ Use lazy loading for non-critical resources (module-based)
- âš ï¸ Use event delegation for dynamic content (some modules)

#### âŒ **NOT IMPLEMENTED** (Future improvements)
- âŒ Advanced performance monitoring
- âŒ Advanced caching strategies
- âŒ Asset optimization

### **Current Implementation Status**

#### **Mobile Performance** âœ… **EXCELLENT**
- Touch event optimization fully implemented
- Viewport handling properly configured
- Mobile-first CSS approach
- Touch-friendly UI elements

#### **Memory Management** âš ï¸ **GOOD**
- Basic cleanup implemented
- Event listener tracking
- Timeout management
- Needs improvement for complex modules

#### **Rendering Performance** âš ï¸ **GOOD**
- Efficient CSS selectors
- CSS transforms for animations
- Basic DOM optimization
- Missing virtual scrolling

#### **Network Performance** âš ï¸ **BASIC**
- Single CSS bundle
- Basic module loading
- Missing advanced caching
- Missing asset optimization

### **Authentication Performance Guidelines** â­ **NEW**

#### **Session Management Optimization**
```javascript
/**
 * Optimized session management for authentication
 */
class AuthPerformanceOptimizer {
    constructor() {
        this.sessionCache = new Map();
        this.authStateCache = null;
        this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
    }
    
    /**
     * Cache session data to reduce API calls
     */
    cacheSession(session) {
        this.authStateCache = {
            session,
            timestamp: Date.now()
        };
    }
    
    /**
     * Get cached session if still valid
     */
    getCachedSession() {
        if (!this.authStateCache) return null;
        
        const isExpired = Date.now() - this.authStateCache.timestamp > this.cacheTimeout;
        if (isExpired) {
            this.authStateCache = null;
            return null;
        }
        
        return this.authStateCache.session;
    }
    
    /**
     * Debounce authentication state changes
     */
    debounceAuthStateChange(callback, delay = 300) {
        let timeoutId;
        return (...args) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => callback.apply(this, args), delay);
        };
    }
}
```

#### **Authentication Performance Best Practices**
```javascript
// âœ… Good - Efficient authentication state management
class OptimizedAuthService {
    constructor() {
        this.authStateListeners = [];
        this.debouncedStateChange = this.debounceAuthStateChange(
            this.notifyListeners.bind(this), 
            100
        );
    }
    
    // Debounce state changes to prevent excessive UI updates
    debounceAuthStateChange(callback, delay) {
        let timeoutId;
        return (...args) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => callback.apply(this, args), delay);
        };
    }
    
    // Cache user data to reduce API calls
    async getCurrentUser() {
        if (this.cachedUser && this.isCacheValid()) {
            return this.cachedUser;
        }
        
        const user = await this.fetchUserFromAPI();
        this.cachedUser = user;
        this.cacheTimestamp = Date.now();
        return user;
    }
}

// âœ… Good - Optimized authentication UI updates
class OptimizedAuthManager {
    constructor() {
        this.updateQueue = [];
        this.isUpdating = false;
    }
    
    // Batch UI updates to prevent excessive reflows
    batchUIUpdate(updateFunction) {
        this.updateQueue.push(updateFunction);
        
        if (!this.isUpdating) {
            this.isUpdating = true;
            requestAnimationFrame(() => {
                this.processUpdateQueue();
                this.isUpdating = false;
            });
        }
    }
    
    processUpdateQueue() {
        while (this.updateQueue.length > 0) {
            const update = this.updateQueue.shift();
            update();
        }
    }
}
```

#### **Authentication Performance Checklist**
- âœ… Cache authentication state to reduce API calls
- âœ… Debounce authentication state changes
- âœ… Batch UI updates during authentication flows
- âœ… Use requestAnimationFrame for smooth transitions
- âœ… Implement proper session cleanup
- âœ… Optimize authentication form validation
- âœ… Use efficient error handling patterns

### **Common Performance Pitfalls**
âŒ Don't use expensive CSS properties in animations
âŒ Don't manipulate DOM in tight loops
âŒ Don't ignore memory leaks
âŒ Don't load all resources at once
âŒ Don't use complex CSS selectors
âŒ Don't ignore mobile performance
âŒ Don't skip resource cleanup
âŒ Don't use synchronous operations
âŒ Don't ignore bundle size
âŒ Don't skip performance testing
âŒ Don't ignore authentication performance optimization â­ **NEW**
âŒ Don't skip authentication state caching â­ **NEW**
âŒ Don't ignore authentication UI update batching â­ **NEW**