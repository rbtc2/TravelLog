---
globs: *.js
description: TravelLog module patterns and development guidelines
---

# üß© TravelLog Module Patterns

## üìã Overview
This document outlines the specific module patterns and development guidelines used in the TravelLog project, based on the analyzed codebase structure.

## üèóÔ∏è Module Architecture Patterns

### **Simple Tab Module Pattern** (for basic tabs like home.js)
Every simple tab module follows this pattern:

```javascript
/**
 * Simple Tab Module Template
 * @class TabName
 * @version 1.0.0
 * @since 2024-12-29
 */
class TabName {
    constructor() {
        this.isInitialized = false;
        this.eventListeners = [];
    }
    
    /**
     * Renders the tab content
     * @param {HTMLElement} container - Container element
     */
    render(container) {
        this.container = container;
        this.renderContent();
        this.bindEvents();
        this.isInitialized = true;
    }
    
    /**
     * Renders the main content
     */
    renderContent() {
        this.container.innerHTML = `
            <!-- Tab content HTML -->
        `;
    }
    
    /**
     * Binds event listeners
     */
    bindEvents() {
        // Event binding logic
    }
    
    /**
     * Cleans up resources (optional for simple tabs)
     */
    cleanup() {
        // Cleanup event listeners
        this.eventListeners.forEach(({ element, event, handler }) => {
            element.removeEventListener(event, handler);
        });
        this.eventListeners = [];
        
        this.isInitialized = false;
        this.container = null;
    }
}

// Export as class (not instance)
export { TabName };
```

### **Complex Tab Module Pattern** (for advanced tabs like SearchTab.js)
Complex tabs with multiple modules follow this pattern:

```javascript
/**
 * Complex Tab Module Template
 * @class ComplexTabName
 * @version 1.0.0
 * @since 2024-12-29
 */
class ComplexTabName {
    constructor() {
        this.isInitialized = false;
        this.container = null;
        this.eventListeners = [];
        
        // Module instances
        this.modules = new Map();
        this.timeouts = new Map();
    }
    
    /**
     * Renders the tab content
     * @param {HTMLElement} container - Container element
     */
    async render(container) {
        this.container = container;
        await this.initializeModules();
        this.renderContent();
        this.bindEvents();
        this.isInitialized = true;
    }
    
    /**
     * Initialize all modules
     */
    async initializeModules() {
        // Initialize all required modules
    }
    
    /**
     * Renders the main content
     */
    renderContent() {
        this.container.innerHTML = `
            <!-- Tab content HTML -->
        `;
    }
    
    /**
     * Binds event listeners
     */
    bindEvents() {
        // Event binding logic with debouncing
    }
    
    /**
     * Cleans up resources
     */
    async cleanup() {
        // Cleanup all modules
        this.modules.forEach(module => {
            if (module.cleanup) {
                module.cleanup();
            }
        });
        
        // Clear timeouts
        this.timeouts.forEach(timeout => clearTimeout(timeout));
        this.timeouts.clear();
        
        // Cleanup event listeners
        this.eventListeners.forEach(({ element, event, handler }) => {
            element.removeEventListener(event, handler);
        });
        this.eventListeners = [];
        
        this.isInitialized = false;
        this.container = null;
    }
}

// Export as class
export { ComplexTabName };
```

### **Search System Pattern** (Based on [SearchTab.js](mdc:js/modules/search/SearchTab.js))
The search system uses a modular architecture with separate concerns:

```javascript
/**
 * Search System Architecture
 * - SearchEngine: Core search logic
 * - SearchStateManager: State management
 * - FilterManager: Filter handling
 * - SearchResultManager: Result management
 * - SearchUIRenderer: UI rendering
 * - SearchEventHandler: Event handling
 */
class SearchTab {
    constructor() {
        this.isInitialized = false;
        this.container = null;
        
        // Module instances
        this.searchEngine = new SearchEngine();
        this.stateManager = new SearchStateManager();
        this.filterManager = new FilterManager();
        this.resultManager = new SearchResultManager();
        this.uiRenderer = new SearchUIRenderer();
        this.eventHandler = new SearchEventHandler();
        this.storageManager = new StorageManager();
        
        // Debounce and timeout management
        this.searchTimeout = null;
        this.debounceDelay = 300;
        this.timeouts = new Map();
        
        // State management
        this.isSearchMode = false;
        
        // Bind callbacks
        this.bindCallbacks();
    }
    
    /**
     * Bind callback functions to maintain context
     */
    bindCallbacks() {
        this.callbacks = {
            handleSearchInput: this.handleSearchInput.bind(this),
            handleSearchKeypress: this.handleSearchKeypress.bind(this),
            handleSearchFocus: this.handleSearchFocus.bind(this),
            handleSearchBlur: this.handleSearchBlur.bind(this),
            handleSearch: this.handleSearch.bind(this),
            // ... other callbacks
        };
    }
    
    async render(container) {
        this.container = container;
        await this.initializeModules();
        this.renderContent();
        this.bindEvents();
        this.isInitialized = true;
    }
    
    async initializeModules() {
        // Initialize all search modules
        await this.loadInitialData();
    }
    
    renderContent() {
        this.container.innerHTML = this.uiRenderer.renderSearchInterface();
    }
    
    bindEvents() {
        // Bind all search-related events
        this.eventHandler.bindSearchEvents(this.container, this.callbacks);
    }
    
    async cleanup() {
        // Clear all timeouts
        this.timeouts.forEach(timeout => clearTimeout(timeout));
        this.timeouts.clear();
        
        if (this.searchTimeout) {
            clearTimeout(this.searchTimeout);
        }
        
        // Cleanup modules
        if (this.eventHandler && this.eventHandler.cleanup) {
            this.eventHandler.cleanup();
        }
        
        this.isInitialized = false;
        this.container = null;
    }
}
```

### **Calendar Module Pattern** (Based on [CalendarRenderer.js](mdc:js/modules/calendar/CalendarRenderer.js))
The calendar system separates rendering from data management:

```javascript
/**
 * Calendar Module Architecture
 * - CalendarDataManager: Data management
 * - CalendarRenderer: UI rendering
 * - CalendarUtils: Utility functions
 * - Event Handlers: User interaction handling
 */
class CalendarRenderer {
    constructor(container, dataManager) {
        this.container = container;
        this.dataManager = dataManager;
        this.calendarCache = new Map();
    }
    
    renderContent(currentDate, currentView) {
        // Rendering logic with caching
    }
    
    renderCalendarGrid(currentDate, selectedDate) {
        // Grid rendering with performance optimization
    }
}
```

### **Authentication System Pattern** ‚≠ê **NEW PATTERN**
A comprehensive authentication system using Supabase with proper security and state management:

```javascript
/**
 * Authentication System Architecture
 * 
 * Three-tier structure:
 * Level 1: AuthManager - UI management and user interaction
 * Level 2: AuthService - Supabase API calls and business logic  
 * Level 3: SupabaseConfig - Configuration and client initialization
 */

/**
 * Level 1: AuthManager - UI Management Layer
 */
class AuthManager {
    constructor() {
        this.isInitialized = false;
        this.isLoggingOut = false;
        this.isHandlingAuthSuccess = false;
        this.authStateListenerSetup = false;
        this.currentView = 'login'; // 'login' | 'signup' | 'forgot-password'
        
        // UI elements
        this.loginScreen = null;
        this.loginForm = null;
        this.signupForm = null;
        this.forgotPasswordForm = null;
        this.demoBtn = null;
        this.countrySelector = null;
        
        this.init();
    }
    
    /**
     * Initialize authentication manager
     */
    async init() {
        try {
            // Initialize auth service
            await authService.initialize();
            
            // Get DOM elements
            this.loginScreen = document.getElementById('login-screen');
            this.loginForm = document.getElementById('login-form');
            this.demoBtn = document.getElementById('demo-btn');
            
            // Bind events (only once)
            if (!this.isInitialized) {
                this.bindEvents();
                this.setupAuthStateListener();
            }
            
            // Check current auth state
            if (authService.isLoggedIn()) {
                this.handleAuthSuccess();
            } else {
                this.showLoginView();
            }
            
            this.isInitialized = true;
        } catch (error) {
            console.error('Auth manager initialization failed:', error);
            this.showError('Authentication system could not be initialized.');
        }
    }
    
    /**
     * Bind event listeners with proper cleanup
     */
    bindEvents() {
        // Remove existing listeners to prevent duplicates
        if (this.loginForm) {
            this.loginForm.removeEventListener('submit', this.handleLoginSubmit);
        }
        
        // Login form submission
        if (this.loginForm) {
            this.handleLoginSubmit = (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.handleLogin();
            };
            this.loginForm.addEventListener('submit', this.handleLoginSubmit);
        }
        
        // Other event bindings...
    }
    
    /**
     * Setup authentication state listener
     */
    setupAuthStateListener() {
        if (this.authStateListenerSetup) return;
        this.authStateListenerSetup = true;

        authService.onAuthStateChange((event, session) => {
            if (event === 'SIGNED_IN' && session) {
                this.handleAuthSuccess();
            } else if (event === 'SIGNED_OUT') {
                this.handleAuthLogout();
            }
        });
    }
    
    /**
     * Handle login process
     */
    async handleLogin() {
        const email = document.getElementById('email').value;
        const password = document.getElementById('password').value;
        const remember = document.getElementById('remember').checked;

        if (!email || !password) {
            toastManager.show('Ïù¥Î©îÏùºÍ≥º ÎπÑÎ∞ÄÎ≤àÌò∏Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.', 'error');
            return;
        }

        try {
            this.setLoadingState(true);
            
            const result = await authService.signIn(email, password, remember);
            
            if (result && result.success) {
                this.handleAuthSuccess();
            } else {
                toastManager.show('Î°úÍ∑∏Ïù∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.', 'error');
            }
            
        } catch (error) {
            console.error('Login failed:', error);
            // Error messages are handled by authService
        } finally {
            this.setLoadingState(false);
        }
    }
    
    /**
     * Handle authentication success
     */
    handleAuthSuccess() {
        if (this.isHandlingAuthSuccess) return;
        this.isHandlingAuthSuccess = true;

        // Hide login screen
        if (this.loginScreen) {
            this.loginScreen.style.display = 'none';
        }
        
        // Show main app
        const mainApp = document.getElementById('main-app');
        if (mainApp) {
            mainApp.classList.remove('hidden');
        }
        
        // Notify app manager
        if (window.appManager) {
            window.appManager.loginSuccess();
        }

        // Reset state
        setTimeout(() => {
            this.isHandlingAuthSuccess = false;
        }, 1000);
    }
}

/**
 * Level 2: AuthService - Business Logic Layer
 */
class AuthService {
    constructor() {
        this.client = null;
        this.currentUser = null;
        this.isInitialized = false;
        this.isRedirecting = false;
        this.authStateListeners = [];
    }
    
    /**
     * Initialize authentication service
     */
    async initialize() {
        try {
            this.client = await initializeSupabase();
            this.isInitialized = true;
            
            // Check current session
            await this.checkCurrentSession();
            
            // Setup auth state listener
            this.setupAuthStateListener();
            
            console.log('Authentication service initialized.');
        } catch (error) {
            console.error('Auth service initialization failed:', error);
            throw error;
        }
    }
    
    /**
     * Check current session
     */
    async checkCurrentSession() {
        if (!this.client) return;

        try {
            const { data: { session }, error } = await this.client.auth.getSession();
            
            if (error) {
                console.error('Session check failed:', error);
                return;
            }

            if (session) {
                this.currentUser = session.user;
                console.log('Current user:', this.currentUser.email);
            }
        } catch (error) {
            console.error('Session check error:', error);
        }
    }
    
    /**
     * Setup authentication state listener
     */
    setupAuthStateListener() {
        if (!this.client) return;

        this.client.auth.onAuthStateChange((event, session) => {
            this.currentUser = session?.user || null;
            
            // Notify registered listeners
            this.authStateListeners.forEach(listener => {
                try {
                    listener(event, session);
                } catch (error) {
                    console.error('Auth state listener error:', error);
                }
            });
        });
    }
    
    /**
     * Register authentication state change listener
     */
    onAuthStateChange(listener) {
        this.authStateListeners.push(listener);
    }
    
    /**
     * Sign up with email and password
     */
    async signUp(email, password, userData = {}) {
        if (!this.isInitialized) {
            throw new Error('Authentication service not initialized.');
        }

        try {
            const { data, error } = await this.client.auth.signUp({
                email: email,
                password: password,
                options: {
                    data: {
                        full_name: userData.fullName || '',
                        residence_country: userData.residenceCountry || '',
                        avatar_url: userData.avatarUrl || '',
                        created_at: new Date().toISOString()
                    }
                }
            });

            if (error) {
                throw new Error(this.getErrorMessage(error));
            }

            // Email confirmation required
            if (data.user && !data.session) {
                toastManager.show('Ïù¥Î©îÏùº ÌôïÏù∏ ÎßÅÌÅ¨Î•º Î∞úÏÜ°ÌñàÏäµÎãàÎã§. Ïù¥Î©îÏùºÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.', 'info');
                return {
                    success: true,
                    needsEmailConfirmation: true,
                    user: data.user
                };
            }

            // Immediately signed in
            if (data.session) {
                this.currentUser = data.user;
                toastManager.show('ÌöåÏõêÍ∞ÄÏûÖÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!', 'success');
                return {
                    success: true,
                    needsEmailConfirmation: false,
                    user: data.user,
                    session: data.session
                };
            }

        } catch (error) {
            console.error('Signup failed:', error);
            toastManager.show(error.message, 'error');
            throw error;
        }
    }
    
    /**
     * Sign in with email and password
     */
    async signIn(email, password, remember = false) {
        if (!this.isInitialized) {
            throw new Error('Authentication service not initialized.');
        }

        if (!this.client) {
            throw new Error('Supabase client not available.');
        }

        try {
            const { data, error } = await this.client.auth.signInWithPassword({
                email: email,
                password: password
            });

            if (error) {
                throw new Error(this.getErrorMessage(error));
            }

            this.currentUser = data.user;

            toastManager.show('Î°úÍ∑∏Ïù∏ÎêòÏóàÏäµÎãàÎã§!', 'success');
            return {
                success: true,
                user: data.user,
                session: data.session
            };

        } catch (error) {
            console.error('Sign in failed:', error);
            toastManager.show(error.message, 'error');
            throw error;
        }
    }
    
    /**
     * Sign out
     */
    async signOut() {
        if (!this.isInitialized) {
            throw new Error('Authentication service not initialized.');
        }

        try {
            const { error } = await this.client.auth.signOut();

            if (error) {
                throw new Error(this.getErrorMessage(error));
            }

            this.currentUser = null;
            
            // Redirect to login after logout
            setTimeout(() => {
                this.redirectToLogin();
            }, 1000);
            
            return {
                success: true
            };

        } catch (error) {
            console.error('Sign out failed:', error);
            toastManager.show(error.message, 'error');
            throw error;
        }
    }
    
    /**
     * Get current user
     */
    getCurrentUser() {
        return this.currentUser;
    }
    
    /**
     * Check if user is logged in
     */
    isLoggedIn() {
        return !!this.currentUser;
    }
    
    /**
     * Convert Supabase error messages to Korean
     */
    getErrorMessage(error) {
        const errorMessages = {
            'Invalid login credentials': 'Ïù¥Î©îÏùº ÎòêÎäî ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.',
            'Email not confirmed': 'Ïù¥Î©îÏùº Ïù∏Ï¶ùÏù¥ ÌïÑÏöîÌï©ÎãàÎã§. Ïù¥Î©îÏùºÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.',
            'User already registered': 'Ïù¥ÎØ∏ Îì±Î°ùÎêú Ïù¥Î©îÏùºÏûÖÎãàÎã§.',
            'Password should be at least 6 characters': 'ÎπÑÎ∞ÄÎ≤àÌò∏Îäî ÏµúÏÜå 6Ïûê Ïù¥ÏÉÅÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.',
            'Invalid email': 'Ïò¨Î∞îÎ•∏ Ïù¥Î©îÏùº ÌòïÏãùÏù¥ ÏïÑÎãôÎãàÎã§.',
            'Signup requires a valid password': 'Ïú†Ìö®Ìïú ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§.',
            'User not found': 'ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.',
            'Too many requests': 'ÎÑàÎ¨¥ ÎßéÏùÄ ÏöîÏ≤≠Ïù¥ Î∞úÏÉùÌñàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.',
            'Network request failed': 'ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.',
            'Invalid API key': 'API ÌÇ§Í∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§.',
            'Service unavailable': 'ÏÑúÎπÑÏä§Î•º ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.'
        };

        return errorMessages[error.message] || error.message || 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.';
    }
    
    /**
     * Cleanup authentication service
     */
    cleanup() {
        this.authStateListeners = [];
        this.currentUser = null;
        this.isInitialized = false;
    }
}

/**
 * Level 3: SupabaseConfig - Configuration Layer
 */
export const SUPABASE_CONFIG = {
    url: 'https://your-project.supabase.co',
    anonKey: 'your-anon-key',
    serviceRoleKey: 'your-service-role-key'
};

let supabaseClient = null;

/**
 * Initialize Supabase client
 */
export async function initializeSupabase() {
    if (supabaseClient) {
        return supabaseClient;
    }

    try {
        // Use global Supabase object
        if (typeof window !== 'undefined' && window.supabase) {
            supabaseClient = window.supabase.createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey, {
                auth: {
                    autoRefreshToken: true,
                    persistSession: true,
                    detectSessionInUrl: true
                }
            });
        } else {
            // Dynamic import fallback
            const { createClient } = await import('https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm');
            supabaseClient = createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey, {
                auth: {
                    autoRefreshToken: true,
                    persistSession: true,
                    detectSessionInUrl: true
                }
            });
        }

        console.log('Supabase client initialized.');
        return supabaseClient;
    } catch (error) {
        console.error('Supabase client initialization failed:', error);
        throw new Error('Could not initialize Supabase client.');
    }
}

// Singleton instance
export const authService = new AuthService();
```

#### **Key Characteristics of Authentication System Pattern:**

1. **Three-Tier Architecture**: Clear separation between UI, business logic, and configuration
2. **Security First**: Proper error handling, input validation, and secure session management
3. **State Management**: Centralized authentication state with proper listeners
4. **Error Handling**: Korean error messages for better user experience
5. **Session Management**: Automatic token refresh and session persistence
6. **Modular Design**: Each layer has specific responsibilities
7. **Event-Driven**: Authentication state changes trigger appropriate UI updates
8. **Resource Management**: Proper cleanup of listeners and resources
9. **Extensibility**: Easy to add new authentication methods or providers
10. **Type Safety**: Proper error handling and validation

#### **Usage Pattern for Authentication:**

```javascript
// Step 1: Initialize authentication
const authManager = new AuthManager();
await authManager.init();

// Step 2: Check authentication state
if (authService.isLoggedIn()) {
    const user = authService.getCurrentUser();
    console.log('User logged in:', user.email);
}

// Step 3: Handle authentication events
authService.onAuthStateChange((event, session) => {
    if (event === 'SIGNED_IN') {
        console.log('User signed in');
    } else if (event === 'SIGNED_OUT') {
        console.log('User signed out');
    }
});

// Step 4: Perform authentication operations
await authService.signIn(email, password);
await authService.signUp(email, password, userData);
await authService.signOut();
```

#### **Benefits of This Pattern:**

- **Security**: Proper authentication flow with secure session management
- **User Experience**: Korean error messages and smooth state transitions
- **Maintainability**: Clear separation of concerns across three layers
- **Extensibility**: Easy to add new authentication providers or methods
- **Performance**: Efficient state management and resource cleanup
- **Reliability**: Comprehensive error handling and validation

### **API Integration Pattern** ‚≠ê **NEW PATTERN**
A comprehensive pattern for integrating external APIs with robust error handling and fallback systems:

```javascript
/**
 * API Integration Architecture
 * 
 * Three-tier structure:
 * Level 1: API Service Layer - External API communication
 * Level 2: Data Manager - Data processing and caching
 * Level 3: UI Component - User interface and interaction
 */

/**
 * Level 1: API Service Layer
 */
class APIService {
    constructor(config) {
        this.baseURL = config.baseURL;
        this.timeout = config.timeout || 10000;
        this.retryAttempts = config.retryAttempts || 3;
        this.cache = new Map();
        this.cacheTimeout = config.cacheTimeout || 5 * 60 * 1000; // 5 minutes
    }
    
    /**
     * Generic API call with retry logic and caching
     */
    async callAPI(endpoint, options = {}) {
        const cacheKey = this.generateCacheKey(endpoint, options);
        
        // Check cache first
        if (this.cache.has(cacheKey)) {
            const cached = this.cache.get(cacheKey);
            if (Date.now() - cached.timestamp < this.cacheTimeout) {
                return cached.data;
            }
        }
        
        // Retry logic
        for (let attempt = 1; attempt <= this.retryAttempts; attempt++) {
            try {
                const response = await this.makeRequest(endpoint, options);
                
                // Cache successful response
                this.cache.set(cacheKey, {
                    data: response,
                    timestamp: Date.now()
                });
                
                return response;
            } catch (error) {
                if (attempt === this.retryAttempts) {
                    throw error;
                }
                
                // Exponential backoff
                await this.delay(Math.pow(2, attempt) * 1000);
            }
        }
    }
    
    /**
     * Make HTTP request with timeout
     */
    async makeRequest(endpoint, options) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);
        
        try {
            const response = await fetch(`${this.baseURL}${endpoint}`, {
                ...options,
                signal: controller.signal,
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    ...options.headers
                }
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`API ÏùëÎãµ Ïò§Î•ò: ${response.status} ${response.statusText}`);
            }
            
            const data = await response.json();
            
            if (!data || !data.data) {
                throw new Error('API ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.');
            }
            
            return data;
        } catch (error) {
            clearTimeout(timeoutId);
            throw error;
        }
    }
    
    /**
     * Generate cache key for request
     */
    generateCacheKey(endpoint, options) {
        return `${endpoint}_${JSON.stringify(options)}`;
    }
    
    /**
     * Delay utility for retry logic
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

/**
 * Level 2: Data Manager with Fallback System
 */
class APIDataManager {
    constructor(apiService, fallbackData) {
        this.apiService = apiService;
        this.fallbackData = fallbackData;
        this.isOnline = navigator.onLine;
        
        // Monitor online status
        window.addEventListener('online', () => {
            this.isOnline = true;
            this.clearCache();
        });
        
        window.addEventListener('offline', () => {
            this.isOnline = false;
        });
    }
    
    /**
     * Get data with fallback system
     */
    async getData(key, apiCall) {
        try {
            // Try API first if online
            if (this.isOnline) {
                const data = await apiCall();
                return this.processAPIData(data);
            }
        } catch (error) {
            console.warn('API Ìò∏Ï∂ú Ïã§Ìå®, Ìè¥Î∞± Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©:', error);
        }
        
        // Use fallback data
        return this.getFallbackData(key);
    }
    
    /**
     * Process API response data
     */
    processAPIData(data) {
        // Transform API data to internal format
        return data.data.map(item => ({
            name: item,
            nameEn: item,
            source: 'api'
        }));
    }
    
    /**
     * Get fallback data
     */
    getFallbackData(key) {
        const fallback = this.fallbackData[key];
        if (!fallback) {
            throw new Error(`Ìè¥Î∞± Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${key}`);
        }
        
        return fallback.map(item => ({
            ...item,
            source: 'fallback'
        }));
    }
    
    /**
     * Clear cache when coming back online
     */
    clearCache() {
        this.apiService.cache.clear();
    }
}

/**
 * Level 3: UI Component with API Integration
 */
class APIIntegratedComponent {
    constructor(container, dataManager, options = {}) {
        this.container = container;
        this.dataManager = dataManager;
        this.options = {
            placeholder: 'Í≤ÄÏÉâÌïòÏÑ∏Ïöî...',
            maxResults: 50,
            showLoading: true,
            ...options
        };
        
        this.isLoading = false;
        this.data = [];
        this.filteredData = [];
        this.eventListeners = new Map();
    }
    
    /**
     * Load data with API integration
     */
    async loadData(key, apiCall) {
        try {
            this.setLoading(true);
            
            const data = await this.dataManager.getData(key, apiCall);
            this.data = data;
            this.filteredData = data;
            
            this.render();
        } catch (error) {
            console.error('Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:', error);
            this.showError('Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
        } finally {
            this.setLoading(false);
        }
    }
    
    /**
     * Search with integrated data sources
     */
    search(query) {
        const searchTerm = query.toLowerCase().trim();
        
        if (searchTerm === '') {
            this.filteredData = this.data;
        } else {
            this.filteredData = this.data.filter(item => 
                item.name.toLowerCase().includes(searchTerm) ||
                item.nameEn.toLowerCase().includes(searchTerm)
            );
        }
        
        this.render();
    }
    
    /**
     * Set loading state
     */
    setLoading(loading) {
        this.isLoading = loading;
        this.render();
    }
    
    /**
     * Show error message
     */
    showError(message) {
        this.container.innerHTML = `
            <div class="error-message">
                <span class="error-icon">‚ö†Ô∏è</span>
                <span>${message}</span>
            </div>
        `;
    }
    
    /**
     * Render component
     */
    render() {
        if (this.isLoading) {
            this.container.innerHTML = `
                <div class="loading-indicator">
                    <div class="loading-spinner"></div>
                    <span>Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...</span>
                </div>
            `;
            return;
        }
        
        if (this.filteredData.length === 0) {
            this.container.innerHTML = `
                <div class="no-data">
                    <span>Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.</span>
                </div>
            `;
            return;
        }
        
        // Render data items
        this.container.innerHTML = this.filteredData.map(item => 
            this.renderItem(item)
        ).join('');
    }
    
    /**
     * Render individual item
     */
    renderItem(item) {
        return `
            <div class="data-item ${item.source === 'api' ? 'api-item' : 'fallback-item'}">
                <span class="item-name">${item.name}</span>
                ${item.name !== item.nameEn ? `<span class="item-name-en">${item.nameEn}</span>` : ''}
                ${item.source === 'api' ? '<span class="api-badge">API</span>' : ''}
            </div>
        `;
    }
    
    /**
     * Cleanup resources
     */
    cleanup() {
        this.eventListeners.forEach((listeners, element) => {
            listeners.forEach(({ event, handler }) => {
                element.removeEventListener(event, handler);
            });
        });
        this.eventListeners.clear();
    }
}

/**
 * Usage Example: City Selector with API Integration
 */
class CitySelectorWithAPI extends APIIntegratedComponent {
    constructor(container, options = {}) {
        // API service configuration
        const apiService = new APIService({
            baseURL: 'https://countriesnow.space/api/v0.1',
            timeout: 10000,
            retryAttempts: 3,
            cacheTimeout: 5 * 60 * 1000
        });
        
        // Fallback data
        const fallbackData = {
            'South Korea': [
                { name: 'ÏÑúÏö∏', nameEn: 'Seoul' },
                { name: 'Î∂ÄÏÇ∞', nameEn: 'Busan' },
                { name: 'ÎåÄÍµ¨', nameEn: 'Daegu' }
            ],
            'Japan': [
                { name: 'ÎèÑÏøÑ', nameEn: 'Tokyo' },
                { name: 'Ïò§ÏÇ¨Ïπ¥', nameEn: 'Osaka' },
                { name: 'ÍµêÌÜ†', nameEn: 'Kyoto' }
            ]
        };
        
        const dataManager = new APIDataManager(apiService, fallbackData);
        
        super(container, dataManager, options);
    }
    
    /**
     * Load cities for specific country
     */
    async loadCitiesForCountry(countryName) {
        const apiCall = () => this.dataManager.apiService.callAPI('/countries/cities', {
            method: 'POST',
            body: JSON.stringify({ country: countryName })
        });
        
        await this.loadData(countryName, apiCall);
    }
}
```

#### **Key Characteristics of API Integration Pattern:**

1. **Three-Tier Architecture**: Clear separation between API service, data management, and UI components
2. **Robust Error Handling**: Comprehensive error handling with retry logic and fallback systems
3. **Caching Strategy**: Intelligent caching to reduce API calls and improve performance
4. **Offline Support**: Graceful degradation when network is unavailable
5. **Retry Logic**: Exponential backoff for failed requests
6. **Data Transformation**: Consistent data format regardless of source (API or fallback)
7. **Loading States**: Proper loading indicators and error messages
8. **Resource Management**: Cleanup of resources and event listeners
9. **Configurable**: Flexible configuration for different API endpoints and requirements
10. **Type Safety**: Proper error handling and data validation

#### **Usage Pattern for API Integration:**

```javascript
// Step 1: Configure API service
const apiService = new APIService({
    baseURL: 'https://api.example.com',
    timeout: 10000,
    retryAttempts: 3
});

// Step 2: Setup data manager with fallback
const dataManager = new APIDataManager(apiService, fallbackData);

// Step 3: Create component
const component = new APIIntegratedComponent(container, dataManager);

// Step 4: Load data
await component.loadData('key', () => apiService.callAPI('/endpoint'));

// Step 5: Handle user interactions
component.search('query');
```

#### **Benefits of This Pattern:**

- **Reliability**: Robust error handling and fallback systems ensure consistent user experience
- **Performance**: Intelligent caching reduces API calls and improves response times
- **Maintainability**: Clear separation of concerns makes the code easy to maintain and extend
- **Flexibility**: Configurable components can be adapted for different APIs and use cases
- **User Experience**: Proper loading states and error messages provide clear feedback

### **Extensible Sub-Tab Collection System Pattern** ‚≠ê **NEW PATTERN**
A sophisticated pattern for creating expandable collection systems with dynamic sub-tab navigation:

```javascript
/**
 * Extensible Sub-Tab Collection System Architecture
 * 
 * Four-tier hierarchical structure:
 * Level 1: Main Container (TravelCollectionView)
 * Level 2: Sub-Tab Manager (CollectionTabManager) 
 * Level 3: Abstract Base Class (BaseCollectionView)
 * Level 4: Concrete Implementation (CountriesCollectionView, CitiesCollectionView, etc.)
 */

/**
 * Level 1: Main Container with Plugin Registration System
 */
class ExtensibleCollectionView {
    constructor(controller) {
        this.controller = controller;
        this.eventManager = new EventManager();
        this.tabManager = new CollectionTabManager(controller);
        
        // Register collection plugins
        this.registerCollections();
    }
    
    /**
     * Plugin registration pattern with dynamic loading
     */
    registerCollections() {
        // Register collection with lazy loading
        this.tabManager.registerCollection('countries', {
            type: 'countries',
            icon: 'üè¥',
            title: 'Countries',
            description: 'Your visited countries collection'
        }, async () => {
            const { CountriesCollectionView } = await import('./collections/CountriesCollectionView.js');
            return CountriesCollectionView;
        });
        
        // Future extensibility pattern
        this.tabManager.registerCollection('cities', {
            type: 'cities', 
            icon: 'üèôÔ∏è',
            title: 'Cities',
            description: 'Your visited cities collection'
        }, async () => {
            const { CitiesCollectionView } = await import('./collections/CitiesCollectionView.js');
            return CitiesCollectionView;
        });
    }
    
    async render(container) {
        this.container = container;
        this.renderContent();
        await this.tabManager.render(container.querySelector('.collection-content'));
        this.bindEvents();
    }
}

/**
 * Level 2: Sub-Tab Manager with Dynamic Module Loading
 */
class CollectionTabManager {
    constructor(controller) {
        this.controller = controller;
        this.eventManager = new EventManager();
        
        // Plugin registry
        this.collections = new Map();
        this.loadedCollections = new Map(); // Instance cache
        
        this.currentCollection = null;
        this.defaultCollection = 'countries';
    }
    
    /**
     * Plugin registration interface
     * @param {string} type - Collection type identifier
     * @param {Object} config - Collection configuration
     * @param {Function} viewClassLoader - Dynamic import function
     */
    registerCollection(type, config, viewClassLoader) {
        this.collections.set(type, {
            config,
            viewClassLoader,
            isLoaded: false,
            instance: null
        });
    }
    
    /**
     * Lazy loading with instance caching
     */
    async loadCollection(type) {
        if (this.loadedCollections.has(type)) {
            return this.loadedCollections.get(type);
        }
        
        const collectionInfo = this.collections.get(type);
        if (!collectionInfo) {
            throw new Error(`Unregistered collection: ${type}`);
        }
        
        // Dynamic module loading
        const ViewClass = await collectionInfo.viewClassLoader();
        
        // Instantiate with dependency injection
        const collection = new ViewClass(this.controller, collectionInfo.config);
        
        // Cache management
        this.loadedCollections.set(type, collection);
        collectionInfo.isLoaded = true;
        
        return collection;
    }
    
    /**
     * Sub-tab navigation with cleanup
     */
    async switchToCollection(type) {
        // Cleanup current collection
        this.cleanupCurrentCollection();
        
        try {
            // Load new collection
            const collection = await this.loadCollection(type);
            const contentContainer = this.container.querySelector('.collection-content');
            
            // Render new collection
            await collection.render(contentContainer);
            this.currentCollection = type;
            
            // Update tab UI
            this.updateTabActiveState(type);
            
            // Dispatch change event
            this.eventManager.dispatchEvent(new CustomEvent('collectionTabManager:collectionChanged', {
                detail: { type, collection }
            }));
        } catch (error) {
            console.error(`Failed to switch to collection ${type}:`, error);
        }
    }
    
    cleanupCurrentCollection() {
        if (this.currentCollection && this.loadedCollections.has(this.currentCollection)) {
            const collection = this.loadedCollections.get(this.currentCollection);
            if (collection && collection.cleanup) {
                collection.cleanup();
            }
        }
    }
}

/**
 * Level 3: Abstract Base Class with Template Method Pattern
 */
export class BaseCollectionView {
    constructor(controller, config) {
        // Abstract class enforcement
        if (this.constructor === BaseCollectionView) {
            throw new Error("BaseCollectionView is an abstract class and cannot be instantiated directly.");
        }
        
        this.controller = controller;
        this.config = config; // { type, icon, title, description }
        this.eventManager = new EventManager();
        
        // Common state management
        this.container = null;
        this.isInitialized = false;
        this.isLoading = false;
        this.data = [];
        
        // Common filter/sort state
        this.currentFilter = 'all';
        this.sortBy = 'visitCount';
        
        this.bindMethods();
    }
    
    /**
     * Template Method Pattern - Main rendering lifecycle
     */
    async render(container) {
        this.container = container;
        this.isLoading = true;
        
        try {
            // Render loading state
            this.renderContent();
            
            // Load data
            await this.loadData();
            this.isLoading = false;
            
            // Render actual content
            this.renderContent();
            this.bindEvents();
            this.isInitialized = true;
        } catch (error) {
            this.isLoading = false;
            console.error('Collection render failed:', error);
            this.renderError(error);
        }
    }
    
    /**
     * Template method - concrete classes must implement
     */
    renderContent() {
        const headerHTML = this.renderHeader();
        const controlsHTML = this.renderControls();
        const statsHTML = this.renderStats();
        const itemsHTML = this.isLoading ? this.renderLoading() : this.renderItems();
        
        this.container.innerHTML = `
            ${headerHTML}
            ${controlsHTML}
            ${statsHTML}
            ${itemsHTML}
        `;
    }
    
    // Abstract methods - must be implemented by concrete classes
    async loadData() { throw new Error("loadData() must be implemented by concrete class"); }
    renderFilterControls() { throw new Error("renderFilterControls() must be implemented by concrete class"); }
    renderSortControls() { throw new Error("renderSortControls() must be implemented by concrete class"); }
    renderStats() { throw new Error("renderStats() must be implemented by concrete class"); }
    renderItems() { throw new Error("renderItems() must be implemented by concrete class"); }
    getFilteredAndSortedData() { throw new Error("getFilteredAndSortedData() must be implemented by concrete class"); }
    
    // Common implementations
    renderHeader() {
        return `
            <div class="collection-header">
                <h2 class="collection-title">
                    <span class="collection-icon">${this.config.icon}</span>
                    ${this.config.title}
                </h2>
                <p class="collection-description">${this.config.description}</p>
            </div>
        `;
    }
    
    renderControls() {
        return `
            <div class="collection-controls">
                <div class="filter-controls">
                    ${this.renderFilterControls()}
                </div>
                <div class="sort-controls">
                    ${this.renderSortControls()}
                </div>
            </div>
        `;
    }
    
    renderLoading() {
        return `
            <div class="loading-indicator">
                <div class="loading-spinner"></div>
                <p>Loading ${this.config.title.toLowerCase()}...</p>
            </div>
        `;
    }
    
    renderError(error) {
        return `
            <div class="error-message">
                <p>Failed to load ${this.config.title.toLowerCase()}: ${error.message}</p>
            </div>
        `;
    }
    
    cleanup() {
        this.eventManager.cleanup();
        this.isInitialized = false;
        this.container = null;
        this.data = [];
    }
}

/**
 * Level 4: Concrete Implementation with Business Logic
 */
export class CountriesCollectionView extends BaseCollectionView {
    constructor(controller, config) {
        super(controller, config);
        
        // Collection-specific state
        this.currentContinent = 'all';
        this.visitedCountries = [];
        
        // Bind collection-specific handlers
        this.handleContinentFilter = this.handleContinentFilter.bind(this);
        this.handleCountryClick = this.handleCountryClick.bind(this);
    }
    
    // Implement abstract methods
    async loadData() {
        const visitedData = this.controller.getVisitedCountries();
        if (visitedData && visitedData.visitedCountryCodes && visitedData.visitedCountryCodes.length > 0) {
            this.visitedCountries = Object.values(visitedData.countries);
        } else {
            // Fallback to demo data
            this.visitedCountries = this.generateDemoVisitedCountries();
        }
    }
    
    renderFilterControls() {
        const filterOptions = this.generateContinentFilterOptions();
        return `
            <div class="filter-group">
                <label for="continent-filter" class="filter-label">Continent Filter</label>
                <select id="continent-filter" class="filter-control continent-filter">
                    ${filterOptions}
                </select>
            </div>
        `;
    }
    
    renderSortControls() {
        return `
            <div class="sort-group">
                <label for="country-sort" class="sort-label">Sort By</label>
                <select id="country-sort" class="sort-control">
                    <option value="visitCount" ${this.sortBy === 'visitCount' ? 'selected' : ''}>Visit Count</option>
                    <option value="lastVisit" ${this.sortBy === 'lastVisit' ? 'selected' : ''}>Last Visit</option>
                    <option value="alphabet" ${this.sortBy === 'alphabet' ? 'selected' : ''}>Alphabetical</option>
                </select>
            </div>
        `;
    }
    
    renderStats() {
        return `
            <div class="collection-stats-simple">
                <div class="stats-info">
                    <span class="stats-icon">üìä</span>
                    <span class="stats-text">Total ${this.visitedCountries.length} countries visited</span>
                </div>
            </div>
        `;
    }
    
    renderItems() {
        const filteredData = this.getFilteredAndSortedData();
        return `
            <div class="collection-grid">
                ${filteredData.map(country => this.renderCountryCard(country)).join('')}
            </div>
        `;
    }
    
    getFilteredAndSortedData() {
        let filtered = [...this.visitedCountries];
        
        // Apply continent filter
        if (this.currentContinent !== 'all') {
            filtered = filtered.filter(country => country.continent === this.currentContinent);
        }
        
        // Apply sorting
        filtered.sort((a, b) => {
            switch (this.sortBy) {
                case 'visitCount':
                    return (b.visitCount || 1) - (a.visitCount || 1);
                case 'lastVisit':
                    return new Date(b.lastVisit || 0) - new Date(a.lastVisit || 0);
                case 'alphabet':
                    return a.name.localeCompare(b.name);
                default:
                    return 0;
            }
        });
        
        return filtered;
    }
    
    // Collection-specific event handlers
    bindCustomEvents() {
        const continentFilter = this.container.querySelector('#continent-filter');
        const sortControl = this.container.querySelector('#country-sort');
        
        if (continentFilter) {
            this.eventManager.add(continentFilter, 'change', this.handleContinentFilter);
        }
        
        if (sortControl) {
            this.eventManager.add(sortControl, 'change', (e) => {
                this.sortBy = e.target.value;
                this.updateItems();
            });
        }
    }
}
```

#### **Key Characteristics of Extensible Sub-Tab Collection System:**

1. **Four-Tier Architecture**: Clear separation of concerns across multiple abstraction levels
2. **Plugin System**: Dynamic registration and loading of collection types
3. **Template Method Pattern**: Abstract base class defines common workflow, concrete classes implement specifics
4. **Lazy Loading**: Collections are loaded only when accessed, improving performance
5. **Instance Caching**: Loaded collections are cached to avoid repeated instantiation
6. **Dynamic Import**: ES6 modules are loaded asynchronously for better code splitting
7. **Event-Driven Communication**: Loose coupling between components via custom events
8. **Resource Management**: Proper cleanup of instances and event listeners
9. **Extensibility**: New collection types can be added without modifying existing code
10. **Type Safety**: Abstract class enforcement prevents direct instantiation

#### **Usage Pattern for Adding New Collection Types:**

```javascript
// Step 1: Create new collection view
export class CitiesCollectionView extends BaseCollectionView {
    async loadData() {
        // Load cities data
    }
    
    renderFilterControls() {
        // City-specific filters (country, rating, etc.)
    }
    
    renderItems() {
        // Render city cards
    }
    
    getFilteredAndSortedData() {
        // City-specific filtering/sorting logic
    }
}

// Step 2: Register in main container
this.tabManager.registerCollection('cities', {
    type: 'cities',
    icon: 'üèôÔ∏è', 
    title: 'Cities',
    description: 'Your visited cities collection'
}, async () => {
    const { CitiesCollectionView } = await import('./collections/CitiesCollectionView.js');
    return CitiesCollectionView;
});

// Step 3: Add corresponding CSS styles and data service methods
```

#### **Benefits of This Pattern:**

- **Scalability**: Unlimited collection types can be added
- **Maintainability**: Each collection is independently developed and tested
- **Performance**: Lazy loading reduces initial bundle size
- **Consistency**: Common UI patterns enforced by abstract base class
- **Flexibility**: Each collection can have unique business logic while maintaining interface compatibility

## üîÑ State Management Patterns

### **State Manager Pattern**
```javascript
/**
 * State Manager for complex modules
 */
class StateManager {
    constructor() {
        this.state = {
            currentView: 'initial',
            data: null,
            loading: false,
            error: null
        };
        this.listeners = [];
    }
    
    getState() {
        return { ...this.state };
    }
    
    setState(newState) {
        const prevState = { ...this.state };
        this.state = { ...this.state, ...newState };
        this.notifyListeners(prevState, this.state);
    }
    
    subscribe(listener) {
        this.listeners.push(listener);
        return () => {
            this.listeners = this.listeners.filter(l => l !== listener);
        };
    }
    
    notifyListeners(prevState, currentState) {
        this.listeners.forEach(listener => {
            listener(prevState, currentState);
        });
    }
}
```

### **Event Manager Pattern**
```javascript
/**
 * Centralized event management
 */
class EventManager {
    constructor() {
        this.listeners = new Map();
    }
    
    addEventListener(element, event, handler) {
        if (!this.listeners.has(element)) {
            this.listeners.set(element, []);
        }
        
        this.listeners.get(element).push({ event, handler });
        element.addEventListener(event, handler);
    }
    
    removeEventListener(element, event, handler) {
        if (this.listeners.has(element)) {
            const elementListeners = this.listeners.get(element);
            const index = elementListeners.findIndex(
                l => l.event === event && l.handler === handler
            );
            if (index > -1) {
                elementListeners.splice(index, 1);
                element.removeEventListener(event, handler);
            }
        }
    }
    
    cleanup() {
        this.listeners.forEach((listeners, element) => {
            listeners.forEach(({ event, handler }) => {
                element.removeEventListener(event, handler);
            });
        });
        this.listeners.clear();
    }
}
```

## üé® UI Component Patterns

### **Modal Manager Pattern**
```javascript
/**
 * Modal management system
 */
class ModalManager {
    constructor() {
        this.activeModals = new Map();
    }
    
    showModal(modalId, content, options = {}) {
        const modal = this.createModal(modalId, content, options);
        document.body.appendChild(modal);
        this.activeModals.set(modalId, modal);
        
        // Animate in
        requestAnimationFrame(() => {
            modal.classList.add('show');
        });
    }
    
    hideModal(modalId) {
        const modal = this.activeModals.get(modalId);
        if (modal) {
            modal.classList.remove('show');
            setTimeout(() => {
                modal.remove();
                this.activeModals.delete(modalId);
            }, 300);
        }
    }
    
    createModal(modalId, content, options) {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.id = modalId;
        modal.innerHTML = `
            <div class="modal-backdrop"></div>
            <div class="modal-content">
                ${content}
            </div>
        `;
        return modal;
    }
}
```

### **Toast Manager Pattern**
```javascript
/**
 * Toast notification system
 */
class ToastManager {
    static show(message, type = 'info', duration = 3000) {
        const toast = document.createElement('div');
        toast.className = `toast toast--${type}`;
        toast.textContent = message;
        
        document.body.appendChild(toast);
        
        // Animate in
        requestAnimationFrame(() => {
            toast.classList.add('show');
        });
        
        // Auto remove
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }, duration);
    }
    
    static success(message, duration) {
        this.show(message, 'success', duration);
    }
    
    static error(message, duration) {
        this.show(message, 'error', duration);
    }
    
    static info(message, duration) {
        this.show(message, 'info', duration);
    }
}
```

## üìä Data Management Patterns

### **Storage Manager Pattern**
```javascript
/**
 * Local storage management
 */
class StorageManager {
    constructor(storageKey = 'travellog_data') {
        this.storageKey = storageKey;
    }
    
    save(key, data) {
        try {
            const serialized = JSON.stringify(data);
            localStorage.setItem(`${this.storageKey}_${key}`, serialized);
            return true;
        } catch (error) {
            console.error('Failed to save data:', error);
            return false;
        }
    }
    
    load(key, defaultValue = null) {
        try {
            const serialized = localStorage.getItem(`${this.storageKey}_${key}`);
            return serialized ? JSON.parse(serialized) : defaultValue;
        } catch (error) {
            console.error('Failed to load data:', error);
            return defaultValue;
        }
    }
    
    remove(key) {
        localStorage.removeItem(`${this.storageKey}_${key}`);
    }
    
    clear() {
        Object.keys(localStorage)
            .filter(key => key.startsWith(this.storageKey))
            .forEach(key => localStorage.removeItem(key));
    }
}
```

### **Data Service Pattern**
```javascript
/**
 * Data service layer
 */
class DataService {
    constructor(storageManager) {
        this.storage = storageManager;
        this.cache = new Map();
    }
    
    async getTravelLogs() {
        const cacheKey = 'travel_logs';
        
        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }
        
        const logs = this.storage.load('travel_logs', []);
        this.cache.set(cacheKey, logs);
        return logs;
    }
    
    async saveTravelLog(logData) {
        const logs = await this.getTravelLogs();
        const newLog = {
            id: this.generateId(),
            ...logData,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        
        logs.push(newLog);
        this.storage.save('travel_logs', logs);
        this.cache.delete('travel_logs');
        
        return newLog;
    }
    
    generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
}
```

## üîß Utility Patterns

### **Debounce Pattern**
```javascript
/**
 * Debounce utility for performance optimization
 */
function debounce(func, wait, immediate = false) {
    let timeout;
    
    return function executedFunction(...args) {
        const later = () => {
            timeout = null;
            if (!immediate) func(...args);
        };
        
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        
        if (callNow) func(...args);
    };
}

// Usage example
const debouncedSearch = debounce(performSearch, 300);
searchInput.addEventListener('input', debouncedSearch);
```

### **Throttle Pattern**
```javascript
/**
 * Throttle utility for performance optimization
 */
function throttle(func, limit) {
    let inThrottle;
    
    return function executedFunction(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// Usage example
const throttledScroll = throttle(handleScroll, 100);
window.addEventListener('scroll', throttledScroll);
```

## üß™ Testing Patterns

### **Module Testing Pattern**
```javascript
/**
 * Test setup for modules
 */
describe('ModuleName', () => {
    let module;
    let container;
    
    beforeEach(() => {
        container = document.createElement('div');
        document.body.appendChild(container);
        module = new ModuleName();
    });
    
    afterEach(() => {
        if (module && module.cleanup) {
            module.cleanup();
        }
        if (container && container.parentNode) {
            container.parentNode.removeChild(container);
        }
    });
    
    it('should render correctly', async () => {
        await module.render(container);
        expect(container.innerHTML).toContain('expected content');
    });
    
    it('should handle events correctly', async () => {
        await module.render(container);
        const button = container.querySelector('.test-button');
        button.click();
        expect(module.someProperty).toBe('expected value');
    });
});
```

## üöÄ Performance Patterns

### **Lazy Loading Pattern**
```javascript
/**
 * Lazy loading for modules
 */
class LazyLoader {
    constructor() {
        this.loadedModules = new Map();
    }
    
    async loadModule(modulePath) {
        if (this.loadedModules.has(modulePath)) {
            return this.loadedModules.get(modulePath);
        }
        
        try {
            const module = await import(modulePath);
            this.loadedModules.set(modulePath, module);
            return module;
        } catch (error) {
            console.error(`Failed to load module ${modulePath}:`, error);
            throw error;
        }
    }
}
```

### **Caching Pattern**
```javascript
/**
 * Simple cache implementation
 */
class Cache {
    constructor(maxSize = 100) {
        this.cache = new Map();
        this.maxSize = maxSize;
    }
    
    get(key) {
        if (this.cache.has(key)) {
            const value = this.cache.get(key);
            // Move to end (LRU)
            this.cache.delete(key);
            this.cache.set(key, value);
            return value;
        }
        return null;
    }
    
    set(key, value) {
        if (this.cache.size >= this.maxSize) {
            // Remove oldest entry
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        this.cache.set(key, value);
    }
    
    clear() {
        this.cache.clear();
    }
}
```

## üìù Documentation Patterns

### **Module Documentation Template**
```javascript
/**
 * Module Name
 * 
 * @description Brief description of the module's purpose
 * @version 1.0.0
 * @since 2024-12-29
 * @author REDIPX
 * 
 * @example
 * const module = new ModuleName();
 * await module.initialize();
 * module.render(container);
 */
class ModuleName {
    /**
     * Creates an instance of ModuleName
     * @param {Object} options - Configuration options
     * @param {string} options.option1 - Description of option1
     * @param {number} options.option2 - Description of option2
     */
    constructor(options = {}) {
        // Implementation
    }
}
```

## üîÆ Best Practices Summary

### **Module Development Guidelines**
1. **Single Responsibility**: Each module should have one clear purpose
2. **Dependency Injection**: Pass dependencies through constructor
3. **Error Handling**: Always handle errors gracefully
4. **Resource Cleanup**: Implement proper cleanup methods
5. **Event Management**: Use centralized event management
6. **State Management**: Keep state management simple and predictable
7. **Performance**: Optimize for mobile devices
8. **Testing**: Write comprehensive tests for all modules
9. **Documentation**: Document all public APIs
10. **Consistency**: Follow established patterns throughout the project
11. **Extensibility**: Design for future expansion using abstract base classes and plugin systems ‚≠ê **NEW**
12. **Lazy Loading**: Implement dynamic module loading for better performance ‚≠ê **NEW**
13. **Template Method Pattern**: Use abstract base classes to enforce common interfaces ‚≠ê **NEW**
14. **Plugin Architecture**: Design systems that can be extended without modifying core code ‚≠ê **NEW**