---
globs: *.js
description: TravelLog module patterns and development guidelines
---

# üß© TravelLog Module Patterns

## üìã Overview
This document outlines the specific module patterns and development guidelines used in the TravelLog project, based on the analyzed codebase structure.

## üèóÔ∏è Module Architecture Patterns

### **Simple Tab Module Pattern** (for basic tabs like home.js)
Every simple tab module follows this pattern:

```javascript
/**
 * Simple Tab Module Template
 * @class TabName
 * @version 1.0.0
 * @since 2024-12-29
 */
class TabName {
    constructor() {
        this.isInitialized = false;
        this.eventListeners = [];
    }
    
    /**
     * Renders the tab content
     * @param {HTMLElement} container - Container element
     */
    render(container) {
        this.container = container;
        this.renderContent();
        this.bindEvents();
        this.isInitialized = true;
    }
    
    /**
     * Renders the main content
     */
    renderContent() {
        this.container.innerHTML = `
            <!-- Tab content HTML -->
        `;
    }
    
    /**
     * Binds event listeners
     */
    bindEvents() {
        // Event binding logic
    }
    
    /**
     * Cleans up resources (optional for simple tabs)
     */
    cleanup() {
        // Cleanup event listeners
        this.eventListeners.forEach(({ element, event, handler }) => {
            element.removeEventListener(event, handler);
        });
        this.eventListeners = [];
        
        this.isInitialized = false;
        this.container = null;
    }
}

// Export as class (not instance)
export { TabName };
```

### **Complex Tab Module Pattern** (for advanced tabs like SearchTab.js)
Complex tabs with multiple modules follow this pattern:

```javascript
/**
 * Complex Tab Module Template
 * @class ComplexTabName
 * @version 1.0.0
 * @since 2024-12-29
 */
class ComplexTabName {
    constructor() {
        this.isInitialized = false;
        this.container = null;
        this.eventListeners = [];
        
        // Module instances
        this.modules = new Map();
        this.timeouts = new Map();
    }
    
    /**
     * Renders the tab content
     * @param {HTMLElement} container - Container element
     */
    async render(container) {
        this.container = container;
        await this.initializeModules();
        this.renderContent();
        this.bindEvents();
        this.isInitialized = true;
    }
    
    /**
     * Initialize all modules
     */
    async initializeModules() {
        // Initialize all required modules
    }
    
    /**
     * Renders the main content
     */
    renderContent() {
        this.container.innerHTML = `
            <!-- Tab content HTML -->
        `;
    }
    
    /**
     * Binds event listeners
     */
    bindEvents() {
        // Event binding logic with debouncing
    }
    
    /**
     * Cleans up resources
     */
    async cleanup() {
        // Cleanup all modules
        this.modules.forEach(module => {
            if (module.cleanup) {
                module.cleanup();
            }
        });
        
        // Clear timeouts
        this.timeouts.forEach(timeout => clearTimeout(timeout));
        this.timeouts.clear();
        
        // Cleanup event listeners
        this.eventListeners.forEach(({ element, event, handler }) => {
            element.removeEventListener(event, handler);
        });
        this.eventListeners = [];
        
        this.isInitialized = false;
        this.container = null;
    }
}

// Export as class
export { ComplexTabName };
```

### **Search System Pattern** (Based on [SearchTab.js](mdc:js/modules/search/SearchTab.js))
The search system uses a modular architecture with separate concerns:

```javascript
/**
 * Search System Architecture
 * - SearchEngine: Core search logic
 * - SearchStateManager: State management
 * - FilterManager: Filter handling
 * - SearchResultManager: Result management
 * - SearchUIRenderer: UI rendering
 * - SearchEventHandler: Event handling
 */
class SearchTab {
    constructor() {
        this.isInitialized = false;
        this.container = null;
        
        // Module instances
        this.searchEngine = new SearchEngine();
        this.stateManager = new SearchStateManager();
        this.filterManager = new FilterManager();
        this.resultManager = new SearchResultManager();
        this.uiRenderer = new SearchUIRenderer();
        this.eventHandler = new SearchEventHandler();
        this.storageManager = new StorageManager();
        
        // Debounce and timeout management
        this.searchTimeout = null;
        this.debounceDelay = 300;
        this.timeouts = new Map();
        
        // State management
        this.isSearchMode = false;
        
        // Bind callbacks
        this.bindCallbacks();
    }
    
    /**
     * Bind callback functions to maintain context
     */
    bindCallbacks() {
        this.callbacks = {
            handleSearchInput: this.handleSearchInput.bind(this),
            handleSearchKeypress: this.handleSearchKeypress.bind(this),
            handleSearchFocus: this.handleSearchFocus.bind(this),
            handleSearchBlur: this.handleSearchBlur.bind(this),
            handleSearch: this.handleSearch.bind(this),
            // ... other callbacks
        };
    }
    
    async render(container) {
        this.container = container;
        await this.initializeModules();
        this.renderContent();
        this.bindEvents();
        this.isInitialized = true;
    }
    
    async initializeModules() {
        // Initialize all search modules
        await this.loadInitialData();
    }
    
    renderContent() {
        this.container.innerHTML = this.uiRenderer.renderSearchInterface();
    }
    
    bindEvents() {
        // Bind all search-related events
        this.eventHandler.bindSearchEvents(this.container, this.callbacks);
    }
    
    async cleanup() {
        // Clear all timeouts
        this.timeouts.forEach(timeout => clearTimeout(timeout));
        this.timeouts.clear();
        
        if (this.searchTimeout) {
            clearTimeout(this.searchTimeout);
        }
        
        // Cleanup modules
        if (this.eventHandler && this.eventHandler.cleanup) {
            this.eventHandler.cleanup();
        }
        
        this.isInitialized = false;
        this.container = null;
    }
}
```

### **Calendar Module Pattern** (Based on [CalendarRenderer.js](mdc:js/modules/calendar/CalendarRenderer.js))
The calendar system separates rendering from data management:

```javascript
/**
 * Calendar Module Architecture
 * - CalendarDataManager: Data management
 * - CalendarRenderer: UI rendering
 * - CalendarUtils: Utility functions
 * - Event Handlers: User interaction handling
 */
class CalendarRenderer {
    constructor(container, dataManager) {
        this.container = container;
        this.dataManager = dataManager;
        this.calendarCache = new Map();
    }
    
    renderContent(currentDate, currentView) {
        // Rendering logic with caching
    }
    
    renderCalendarGrid(currentDate, selectedDate) {
        // Grid rendering with performance optimization
    }
}
```

### **Extensible Sub-Tab Collection System Pattern** ‚≠ê **NEW PATTERN**
A sophisticated pattern for creating expandable collection systems with dynamic sub-tab navigation:

```javascript
/**
 * Extensible Sub-Tab Collection System Architecture
 * 
 * Four-tier hierarchical structure:
 * Level 1: Main Container (TravelCollectionView)
 * Level 2: Sub-Tab Manager (CollectionTabManager) 
 * Level 3: Abstract Base Class (BaseCollectionView)
 * Level 4: Concrete Implementation (CountriesCollectionView, CitiesCollectionView, etc.)
 */

/**
 * Level 1: Main Container with Plugin Registration System
 */
class ExtensibleCollectionView {
    constructor(controller) {
        this.controller = controller;
        this.eventManager = new EventManager();
        this.tabManager = new CollectionTabManager(controller);
        
        // Register collection plugins
        this.registerCollections();
    }
    
    /**
     * Plugin registration pattern with dynamic loading
     */
    registerCollections() {
        // Register collection with lazy loading
        this.tabManager.registerCollection('countries', {
            type: 'countries',
            icon: 'üè¥',
            title: 'Countries',
            description: 'Your visited countries collection'
        }, async () => {
            const { CountriesCollectionView } = await import('./collections/CountriesCollectionView.js');
            return CountriesCollectionView;
        });
        
        // Future extensibility pattern
        this.tabManager.registerCollection('cities', {
            type: 'cities', 
            icon: 'üèôÔ∏è',
            title: 'Cities',
            description: 'Your visited cities collection'
        }, async () => {
            const { CitiesCollectionView } = await import('./collections/CitiesCollectionView.js');
            return CitiesCollectionView;
        });
    }
    
    async render(container) {
        this.container = container;
        this.renderContent();
        await this.tabManager.render(container.querySelector('.collection-content'));
        this.bindEvents();
    }
}

/**
 * Level 2: Sub-Tab Manager with Dynamic Module Loading
 */
class CollectionTabManager {
    constructor(controller) {
        this.controller = controller;
        this.eventManager = new EventManager();
        
        // Plugin registry
        this.collections = new Map();
        this.loadedCollections = new Map(); // Instance cache
        
        this.currentCollection = null;
        this.defaultCollection = 'countries';
    }
    
    /**
     * Plugin registration interface
     * @param {string} type - Collection type identifier
     * @param {Object} config - Collection configuration
     * @param {Function} viewClassLoader - Dynamic import function
     */
    registerCollection(type, config, viewClassLoader) {
        this.collections.set(type, {
            config,
            viewClassLoader,
            isLoaded: false,
            instance: null
        });
    }
    
    /**
     * Lazy loading with instance caching
     */
    async loadCollection(type) {
        if (this.loadedCollections.has(type)) {
            return this.loadedCollections.get(type);
        }
        
        const collectionInfo = this.collections.get(type);
        if (!collectionInfo) {
            throw new Error(`Unregistered collection: ${type}`);
        }
        
        // Dynamic module loading
        const ViewClass = await collectionInfo.viewClassLoader();
        
        // Instantiate with dependency injection
        const collection = new ViewClass(this.controller, collectionInfo.config);
        
        // Cache management
        this.loadedCollections.set(type, collection);
        collectionInfo.isLoaded = true;
        
        return collection;
    }
    
    /**
     * Sub-tab navigation with cleanup
     */
    async switchToCollection(type) {
        // Cleanup current collection
        this.cleanupCurrentCollection();
        
        try {
            // Load new collection
            const collection = await this.loadCollection(type);
            const contentContainer = this.container.querySelector('.collection-content');
            
            // Render new collection
            await collection.render(contentContainer);
            this.currentCollection = type;
            
            // Update tab UI
            this.updateTabActiveState(type);
            
            // Dispatch change event
            this.eventManager.dispatchEvent(new CustomEvent('collectionTabManager:collectionChanged', {
                detail: { type, collection }
            }));
        } catch (error) {
            console.error(`Failed to switch to collection ${type}:`, error);
        }
    }
    
    cleanupCurrentCollection() {
        if (this.currentCollection && this.loadedCollections.has(this.currentCollection)) {
            const collection = this.loadedCollections.get(this.currentCollection);
            if (collection && collection.cleanup) {
                collection.cleanup();
            }
        }
    }
}

/**
 * Level 3: Abstract Base Class with Template Method Pattern
 */
export class BaseCollectionView {
    constructor(controller, config) {
        // Abstract class enforcement
        if (this.constructor === BaseCollectionView) {
            throw new Error("BaseCollectionView is an abstract class and cannot be instantiated directly.");
        }
        
        this.controller = controller;
        this.config = config; // { type, icon, title, description }
        this.eventManager = new EventManager();
        
        // Common state management
        this.container = null;
        this.isInitialized = false;
        this.isLoading = false;
        this.data = [];
        
        // Common filter/sort state
        this.currentFilter = 'all';
        this.sortBy = 'visitCount';
        
        this.bindMethods();
    }
    
    /**
     * Template Method Pattern - Main rendering lifecycle
     */
    async render(container) {
        this.container = container;
        this.isLoading = true;
        
        try {
            // Render loading state
            this.renderContent();
            
            // Load data
            await this.loadData();
            this.isLoading = false;
            
            // Render actual content
            this.renderContent();
            this.bindEvents();
            this.isInitialized = true;
        } catch (error) {
            this.isLoading = false;
            console.error('Collection render failed:', error);
            this.renderError(error);
        }
    }
    
    /**
     * Template method - concrete classes must implement
     */
    renderContent() {
        const headerHTML = this.renderHeader();
        const controlsHTML = this.renderControls();
        const statsHTML = this.renderStats();
        const itemsHTML = this.isLoading ? this.renderLoading() : this.renderItems();
        
        this.container.innerHTML = `
            ${headerHTML}
            ${controlsHTML}
            ${statsHTML}
            ${itemsHTML}
        `;
    }
    
    // Abstract methods - must be implemented by concrete classes
    async loadData() { throw new Error("loadData() must be implemented by concrete class"); }
    renderFilterControls() { throw new Error("renderFilterControls() must be implemented by concrete class"); }
    renderSortControls() { throw new Error("renderSortControls() must be implemented by concrete class"); }
    renderStats() { throw new Error("renderStats() must be implemented by concrete class"); }
    renderItems() { throw new Error("renderItems() must be implemented by concrete class"); }
    getFilteredAndSortedData() { throw new Error("getFilteredAndSortedData() must be implemented by concrete class"); }
    
    // Common implementations
    renderHeader() {
        return `
            <div class="collection-header">
                <h2 class="collection-title">
                    <span class="collection-icon">${this.config.icon}</span>
                    ${this.config.title}
                </h2>
                <p class="collection-description">${this.config.description}</p>
            </div>
        `;
    }
    
    renderControls() {
        return `
            <div class="collection-controls">
                <div class="filter-controls">
                    ${this.renderFilterControls()}
                </div>
                <div class="sort-controls">
                    ${this.renderSortControls()}
                </div>
            </div>
        `;
    }
    
    renderLoading() {
        return `
            <div class="loading-indicator">
                <div class="loading-spinner"></div>
                <p>Loading ${this.config.title.toLowerCase()}...</p>
            </div>
        `;
    }
    
    renderError(error) {
        return `
            <div class="error-message">
                <p>Failed to load ${this.config.title.toLowerCase()}: ${error.message}</p>
            </div>
        `;
    }
    
    cleanup() {
        this.eventManager.cleanup();
        this.isInitialized = false;
        this.container = null;
        this.data = [];
    }
}

/**
 * Level 4: Concrete Implementation with Business Logic
 */
export class CountriesCollectionView extends BaseCollectionView {
    constructor(controller, config) {
        super(controller, config);
        
        // Collection-specific state
        this.currentContinent = 'all';
        this.visitedCountries = [];
        
        // Bind collection-specific handlers
        this.handleContinentFilter = this.handleContinentFilter.bind(this);
        this.handleCountryClick = this.handleCountryClick.bind(this);
    }
    
    // Implement abstract methods
    async loadData() {
        const visitedData = this.controller.getVisitedCountries();
        if (visitedData && visitedData.visitedCountryCodes && visitedData.visitedCountryCodes.length > 0) {
            this.visitedCountries = Object.values(visitedData.countries);
        } else {
            // Fallback to demo data
            this.visitedCountries = this.generateDemoVisitedCountries();
        }
    }
    
    renderFilterControls() {
        const filterOptions = this.generateContinentFilterOptions();
        return `
            <div class="filter-group">
                <label for="continent-filter" class="filter-label">Continent Filter</label>
                <select id="continent-filter" class="filter-control continent-filter">
                    ${filterOptions}
                </select>
            </div>
        `;
    }
    
    renderSortControls() {
        return `
            <div class="sort-group">
                <label for="country-sort" class="sort-label">Sort By</label>
                <select id="country-sort" class="sort-control">
                    <option value="visitCount" ${this.sortBy === 'visitCount' ? 'selected' : ''}>Visit Count</option>
                    <option value="lastVisit" ${this.sortBy === 'lastVisit' ? 'selected' : ''}>Last Visit</option>
                    <option value="alphabet" ${this.sortBy === 'alphabet' ? 'selected' : ''}>Alphabetical</option>
                </select>
            </div>
        `;
    }
    
    renderStats() {
        return `
            <div class="collection-stats-simple">
                <div class="stats-info">
                    <span class="stats-icon">üìä</span>
                    <span class="stats-text">Total ${this.visitedCountries.length} countries visited</span>
                </div>
            </div>
        `;
    }
    
    renderItems() {
        const filteredData = this.getFilteredAndSortedData();
        return `
            <div class="collection-grid">
                ${filteredData.map(country => this.renderCountryCard(country)).join('')}
            </div>
        `;
    }
    
    getFilteredAndSortedData() {
        let filtered = [...this.visitedCountries];
        
        // Apply continent filter
        if (this.currentContinent !== 'all') {
            filtered = filtered.filter(country => country.continent === this.currentContinent);
        }
        
        // Apply sorting
        filtered.sort((a, b) => {
            switch (this.sortBy) {
                case 'visitCount':
                    return (b.visitCount || 1) - (a.visitCount || 1);
                case 'lastVisit':
                    return new Date(b.lastVisit || 0) - new Date(a.lastVisit || 0);
                case 'alphabet':
                    return a.name.localeCompare(b.name);
                default:
                    return 0;
            }
        });
        
        return filtered;
    }
    
    // Collection-specific event handlers
    bindCustomEvents() {
        const continentFilter = this.container.querySelector('#continent-filter');
        const sortControl = this.container.querySelector('#country-sort');
        
        if (continentFilter) {
            this.eventManager.add(continentFilter, 'change', this.handleContinentFilter);
        }
        
        if (sortControl) {
            this.eventManager.add(sortControl, 'change', (e) => {
                this.sortBy = e.target.value;
                this.updateItems();
            });
        }
    }
}
```

#### **Key Characteristics of Extensible Sub-Tab Collection System:**

1. **Four-Tier Architecture**: Clear separation of concerns across multiple abstraction levels
2. **Plugin System**: Dynamic registration and loading of collection types
3. **Template Method Pattern**: Abstract base class defines common workflow, concrete classes implement specifics
4. **Lazy Loading**: Collections are loaded only when accessed, improving performance
5. **Instance Caching**: Loaded collections are cached to avoid repeated instantiation
6. **Dynamic Import**: ES6 modules are loaded asynchronously for better code splitting
7. **Event-Driven Communication**: Loose coupling between components via custom events
8. **Resource Management**: Proper cleanup of instances and event listeners
9. **Extensibility**: New collection types can be added without modifying existing code
10. **Type Safety**: Abstract class enforcement prevents direct instantiation

#### **Usage Pattern for Adding New Collection Types:**

```javascript
// Step 1: Create new collection view
export class CitiesCollectionView extends BaseCollectionView {
    async loadData() {
        // Load cities data
    }
    
    renderFilterControls() {
        // City-specific filters (country, rating, etc.)
    }
    
    renderItems() {
        // Render city cards
    }
    
    getFilteredAndSortedData() {
        // City-specific filtering/sorting logic
    }
}

// Step 2: Register in main container
this.tabManager.registerCollection('cities', {
    type: 'cities',
    icon: 'üèôÔ∏è', 
    title: 'Cities',
    description: 'Your visited cities collection'
}, async () => {
    const { CitiesCollectionView } = await import('./collections/CitiesCollectionView.js');
    return CitiesCollectionView;
});

// Step 3: Add corresponding CSS styles and data service methods
```

#### **Benefits of This Pattern:**

- **Scalability**: Unlimited collection types can be added
- **Maintainability**: Each collection is independently developed and tested
- **Performance**: Lazy loading reduces initial bundle size
- **Consistency**: Common UI patterns enforced by abstract base class
- **Flexibility**: Each collection can have unique business logic while maintaining interface compatibility

## üîÑ State Management Patterns

### **State Manager Pattern**
```javascript
/**
 * State Manager for complex modules
 */
class StateManager {
    constructor() {
        this.state = {
            currentView: 'initial',
            data: null,
            loading: false,
            error: null
        };
        this.listeners = [];
    }
    
    getState() {
        return { ...this.state };
    }
    
    setState(newState) {
        const prevState = { ...this.state };
        this.state = { ...this.state, ...newState };
        this.notifyListeners(prevState, this.state);
    }
    
    subscribe(listener) {
        this.listeners.push(listener);
        return () => {
            this.listeners = this.listeners.filter(l => l !== listener);
        };
    }
    
    notifyListeners(prevState, currentState) {
        this.listeners.forEach(listener => {
            listener(prevState, currentState);
        });
    }
}
```

### **Event Manager Pattern**
```javascript
/**
 * Centralized event management
 */
class EventManager {
    constructor() {
        this.listeners = new Map();
    }
    
    addEventListener(element, event, handler) {
        if (!this.listeners.has(element)) {
            this.listeners.set(element, []);
        }
        
        this.listeners.get(element).push({ event, handler });
        element.addEventListener(event, handler);
    }
    
    removeEventListener(element, event, handler) {
        if (this.listeners.has(element)) {
            const elementListeners = this.listeners.get(element);
            const index = elementListeners.findIndex(
                l => l.event === event && l.handler === handler
            );
            if (index > -1) {
                elementListeners.splice(index, 1);
                element.removeEventListener(event, handler);
            }
        }
    }
    
    cleanup() {
        this.listeners.forEach((listeners, element) => {
            listeners.forEach(({ event, handler }) => {
                element.removeEventListener(event, handler);
            });
        });
        this.listeners.clear();
    }
}
```

## üé® UI Component Patterns

### **Modal Manager Pattern**
```javascript
/**
 * Modal management system
 */
class ModalManager {
    constructor() {
        this.activeModals = new Map();
    }
    
    showModal(modalId, content, options = {}) {
        const modal = this.createModal(modalId, content, options);
        document.body.appendChild(modal);
        this.activeModals.set(modalId, modal);
        
        // Animate in
        requestAnimationFrame(() => {
            modal.classList.add('show');
        });
    }
    
    hideModal(modalId) {
        const modal = this.activeModals.get(modalId);
        if (modal) {
            modal.classList.remove('show');
            setTimeout(() => {
                modal.remove();
                this.activeModals.delete(modalId);
            }, 300);
        }
    }
    
    createModal(modalId, content, options) {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.id = modalId;
        modal.innerHTML = `
            <div class="modal-backdrop"></div>
            <div class="modal-content">
                ${content}
            </div>
        `;
        return modal;
    }
}
```

### **Toast Manager Pattern**
```javascript
/**
 * Toast notification system
 */
class ToastManager {
    static show(message, type = 'info', duration = 3000) {
        const toast = document.createElement('div');
        toast.className = `toast toast--${type}`;
        toast.textContent = message;
        
        document.body.appendChild(toast);
        
        // Animate in
        requestAnimationFrame(() => {
            toast.classList.add('show');
        });
        
        // Auto remove
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }, duration);
    }
    
    static success(message, duration) {
        this.show(message, 'success', duration);
    }
    
    static error(message, duration) {
        this.show(message, 'error', duration);
    }
    
    static info(message, duration) {
        this.show(message, 'info', duration);
    }
}
```

## üìä Data Management Patterns

### **Storage Manager Pattern**
```javascript
/**
 * Local storage management
 */
class StorageManager {
    constructor(storageKey = 'travellog_data') {
        this.storageKey = storageKey;
    }
    
    save(key, data) {
        try {
            const serialized = JSON.stringify(data);
            localStorage.setItem(`${this.storageKey}_${key}`, serialized);
            return true;
        } catch (error) {
            console.error('Failed to save data:', error);
            return false;
        }
    }
    
    load(key, defaultValue = null) {
        try {
            const serialized = localStorage.getItem(`${this.storageKey}_${key}`);
            return serialized ? JSON.parse(serialized) : defaultValue;
        } catch (error) {
            console.error('Failed to load data:', error);
            return defaultValue;
        }
    }
    
    remove(key) {
        localStorage.removeItem(`${this.storageKey}_${key}`);
    }
    
    clear() {
        Object.keys(localStorage)
            .filter(key => key.startsWith(this.storageKey))
            .forEach(key => localStorage.removeItem(key));
    }
}
```

### **Data Service Pattern**
```javascript
/**
 * Data service layer
 */
class DataService {
    constructor(storageManager) {
        this.storage = storageManager;
        this.cache = new Map();
    }
    
    async getTravelLogs() {
        const cacheKey = 'travel_logs';
        
        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }
        
        const logs = this.storage.load('travel_logs', []);
        this.cache.set(cacheKey, logs);
        return logs;
    }
    
    async saveTravelLog(logData) {
        const logs = await this.getTravelLogs();
        const newLog = {
            id: this.generateId(),
            ...logData,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        
        logs.push(newLog);
        this.storage.save('travel_logs', logs);
        this.cache.delete('travel_logs');
        
        return newLog;
    }
    
    generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
}
```

## üîß Utility Patterns

### **Debounce Pattern**
```javascript
/**
 * Debounce utility for performance optimization
 */
function debounce(func, wait, immediate = false) {
    let timeout;
    
    return function executedFunction(...args) {
        const later = () => {
            timeout = null;
            if (!immediate) func(...args);
        };
        
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        
        if (callNow) func(...args);
    };
}

// Usage example
const debouncedSearch = debounce(performSearch, 300);
searchInput.addEventListener('input', debouncedSearch);
```

### **Throttle Pattern**
```javascript
/**
 * Throttle utility for performance optimization
 */
function throttle(func, limit) {
    let inThrottle;
    
    return function executedFunction(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// Usage example
const throttledScroll = throttle(handleScroll, 100);
window.addEventListener('scroll', throttledScroll);
```

## üß™ Testing Patterns

### **Module Testing Pattern**
```javascript
/**
 * Test setup for modules
 */
describe('ModuleName', () => {
    let module;
    let container;
    
    beforeEach(() => {
        container = document.createElement('div');
        document.body.appendChild(container);
        module = new ModuleName();
    });
    
    afterEach(() => {
        if (module && module.cleanup) {
            module.cleanup();
        }
        if (container && container.parentNode) {
            container.parentNode.removeChild(container);
        }
    });
    
    it('should render correctly', async () => {
        await module.render(container);
        expect(container.innerHTML).toContain('expected content');
    });
    
    it('should handle events correctly', async () => {
        await module.render(container);
        const button = container.querySelector('.test-button');
        button.click();
        expect(module.someProperty).toBe('expected value');
    });
});
```

## üöÄ Performance Patterns

### **Lazy Loading Pattern**
```javascript
/**
 * Lazy loading for modules
 */
class LazyLoader {
    constructor() {
        this.loadedModules = new Map();
    }
    
    async loadModule(modulePath) {
        if (this.loadedModules.has(modulePath)) {
            return this.loadedModules.get(modulePath);
        }
        
        try {
            const module = await import(modulePath);
            this.loadedModules.set(modulePath, module);
            return module;
        } catch (error) {
            console.error(`Failed to load module ${modulePath}:`, error);
            throw error;
        }
    }
}
```

### **Caching Pattern**
```javascript
/**
 * Simple cache implementation
 */
class Cache {
    constructor(maxSize = 100) {
        this.cache = new Map();
        this.maxSize = maxSize;
    }
    
    get(key) {
        if (this.cache.has(key)) {
            const value = this.cache.get(key);
            // Move to end (LRU)
            this.cache.delete(key);
            this.cache.set(key, value);
            return value;
        }
        return null;
    }
    
    set(key, value) {
        if (this.cache.size >= this.maxSize) {
            // Remove oldest entry
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        this.cache.set(key, value);
    }
    
    clear() {
        this.cache.clear();
    }
}
```

## üìù Documentation Patterns

### **Module Documentation Template**
```javascript
/**
 * Module Name
 * 
 * @description Brief description of the module's purpose
 * @version 1.0.0
 * @since 2024-12-29
 * @author REDIPX
 * 
 * @example
 * const module = new ModuleName();
 * await module.initialize();
 * module.render(container);
 */
class ModuleName {
    /**
     * Creates an instance of ModuleName
     * @param {Object} options - Configuration options
     * @param {string} options.option1 - Description of option1
     * @param {number} options.option2 - Description of option2
     */
    constructor(options = {}) {
        // Implementation
    }
}
```

## üîÆ Best Practices Summary

### **Module Development Guidelines**
1. **Single Responsibility**: Each module should have one clear purpose
2. **Dependency Injection**: Pass dependencies through constructor
3. **Error Handling**: Always handle errors gracefully
4. **Resource Cleanup**: Implement proper cleanup methods
5. **Event Management**: Use centralized event management
6. **State Management**: Keep state management simple and predictable
7. **Performance**: Optimize for mobile devices
8. **Testing**: Write comprehensive tests for all modules
9. **Documentation**: Document all public APIs
10. **Consistency**: Follow established patterns throughout the project
11. **Extensibility**: Design for future expansion using abstract base classes and plugin systems ‚≠ê **NEW**
12. **Lazy Loading**: Implement dynamic module loading for better performance ‚≠ê **NEW**
13. **Template Method Pattern**: Use abstract base classes to enforce common interfaces ‚≠ê **NEW**
14. **Plugin Architecture**: Design systems that can be extended without modifying core code ‚≠ê **NEW**