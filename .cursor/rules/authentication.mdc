---
globs: *.js,*.html,*.css
description: TravelLog authentication system guidelines and security best practices
---

# ğŸ” TravelLog Authentication Rules

## ğŸ“‹ Overview
This document outlines authentication system guidelines, security best practices, and development patterns for the TravelLog project using Supabase authentication.

## ğŸ¯ Core Authentication Principles

### 1. **Security First**
- Always validate user input on both client and server
- Use secure session management with proper token handling
- Implement proper error handling without exposing sensitive information
- Follow OWASP security guidelines for authentication

### 2. **User Experience**
- Provide clear, Korean error messages for users
- Implement smooth authentication state transitions
- Handle loading states gracefully
- Support offline authentication state persistence

### 3. **Performance**
- Cache authentication state to reduce API calls
- Debounce authentication state changes
- Batch UI updates during authentication flows
- Optimize session management

### 4. **Maintainability**
- Use consistent authentication patterns across the application
- Implement proper error handling and logging
- Follow established module patterns
- Document authentication flows clearly

## ğŸ—ï¸ Authentication Architecture

### **Three-Tier Authentication System**

#### **Level 1: AuthManager (UI Layer)**
- Manages authentication UI components
- Handles user interactions and form validation
- Manages authentication state transitions
- Provides user feedback and error messages

#### **Level 2: AuthService (Business Logic Layer)**
- Handles Supabase API calls
- Manages authentication state
- Implements security policies
- Provides authentication utilities

#### **Level 3: SupabaseConfig (Configuration Layer)**
- Manages Supabase client configuration
- Handles environment-specific settings
- Provides connection management

## ğŸ”§ Authentication Patterns

### **Authentication Manager Pattern**
```javascript
/**
 * Authentication Manager - UI Management Layer
 * Handles all authentication-related UI interactions
 */
class AuthManager {
    constructor() {
        this.isInitialized = false;
        this.isLoggingOut = false;
        this.isHandlingAuthSuccess = false;
        this.authStateListenerSetup = false;
        this.currentView = 'login'; // 'login' | 'signup' | 'forgot-password'
        
        // UI elements
        this.loginScreen = null;
        this.loginForm = null;
        this.signupForm = null;
        this.forgotPasswordForm = null;
        this.demoBtn = null;
        this.countrySelector = null;
        
        this.init();
    }
    
    /**
     * Initialize authentication manager
     * @async
     */
    async init() {
        try {
            // Initialize auth service
            await authService.initialize();
            
            // Get DOM elements
            this.loginScreen = document.getElementById('login-screen');
            this.loginForm = document.getElementById('login-form');
            this.demoBtn = document.getElementById('demo-btn');
            
            // Bind events (only once)
            if (!this.isInitialized) {
                this.bindEvents();
                this.setupAuthStateListener();
            }
            
            // Check current auth state
            if (authService.isLoggedIn()) {
                this.handleAuthSuccess();
            } else {
                this.showLoginView();
            }
            
            this.isInitialized = true;
        } catch (error) {
            console.error('Auth manager initialization failed:', error);
            this.showError('Authentication system could not be initialized.');
        }
    }
    
    /**
     * Bind event listeners with proper cleanup
     */
    bindEvents() {
        // Remove existing listeners to prevent duplicates
        if (this.loginForm) {
            this.loginForm.removeEventListener('submit', this.handleLoginSubmit);
        }
        
        // Login form submission
        if (this.loginForm) {
            this.handleLoginSubmit = (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.handleLogin();
            };
            this.loginForm.addEventListener('submit', this.handleLoginSubmit);
        }
        
        // Other event bindings...
    }
    
    /**
     * Setup authentication state listener
     */
    setupAuthStateListener() {
        if (this.authStateListenerSetup) return;
        this.authStateListenerSetup = true;

        authService.onAuthStateChange((event, session) => {
            if (event === 'SIGNED_IN' && session) {
                this.handleAuthSuccess();
            } else if (event === 'SIGNED_OUT') {
                this.handleAuthLogout();
            }
        });
    }
    
    /**
     * Handle login process with validation
     * @async
     */
    async handleLogin() {
        const email = document.getElementById('email').value;
        const password = document.getElementById('password').value;
        const remember = document.getElementById('remember').checked;

        // Input validation
        if (!email || !password) {
            toastManager.show('ì´ë©”ì¼ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
            return;
        }

        // Email format validation
        if (!this.isValidEmail(email)) {
            toastManager.show('ì˜¬ë°”ë¥¸ ì´ë©”ì¼ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤.', 'error');
            return;
        }

        try {
            this.setLoadingState(true);
            
            const result = await authService.signIn(email, password, remember);
            
            if (result && result.success) {
                this.handleAuthSuccess();
            } else {
                toastManager.show('ë¡œê·¸ì¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error');
            }
            
        } catch (error) {
            console.error('Login failed:', error);
            // Error messages are handled by authService
        } finally {
            this.setLoadingState(false);
        }
    }
    
    /**
     * Validate email format
     * @param {string} email - Email to validate
     * @returns {boolean} - Whether email is valid
     */
    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
    
    /**
     * Handle authentication success
     */
    handleAuthSuccess() {
        if (this.isHandlingAuthSuccess) return;
        this.isHandlingAuthSuccess = true;

        // Hide login screen
        if (this.loginScreen) {
            this.loginScreen.style.display = 'none';
        }
        
        // Show main app
        const mainApp = document.getElementById('main-app');
        if (mainApp) {
            mainApp.classList.remove('hidden');
        }
        
        // Notify app manager
        if (window.appManager) {
            window.appManager.loginSuccess();
        }

        // Reset state
        setTimeout(() => {
            this.isHandlingAuthSuccess = false;
        }, 1000);
    }
}
```

### **Authentication Service Pattern**
```javascript
/**
 * Authentication Service - Business Logic Layer
 * Handles all authentication business logic and Supabase API calls
 */
class AuthService {
    constructor() {
        this.client = null;
        this.currentUser = null;
        this.isInitialized = false;
        this.isRedirecting = false;
        this.authStateListeners = [];
        
        // Performance optimization
        this.authStateCache = null;
        this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
    }
    
    /**
     * Initialize authentication service
     * @async
     */
    async initialize() {
        try {
            this.client = await initializeSupabase();
            this.isInitialized = true;
            
            // Check current session
            await this.checkCurrentSession();
            
            // Setup auth state listener
            this.setupAuthStateListener();
            
            console.log('Authentication service initialized.');
        } catch (error) {
            console.error('Auth service initialization failed:', error);
            throw error;
        }
    }
    
    /**
     * Check current session with caching
     * @async
     */
    async checkCurrentSession() {
        if (!this.client) return;

        // Check cache first
        const cachedSession = this.getCachedSession();
        if (cachedSession) {
            this.currentUser = cachedSession.user;
            return;
        }

        try {
            const { data: { session }, error } = await this.client.auth.getSession();
            
            if (error) {
                console.error('Session check failed:', error);
                return;
            }

            if (session) {
                this.currentUser = session.user;
                this.cacheSession(session);
                console.log('Current user:', this.currentUser.email);
            }
        } catch (error) {
            console.error('Session check error:', error);
        }
    }
    
    /**
     * Cache session data for performance
     * @param {Object} session - Session data to cache
     */
    cacheSession(session) {
        this.authStateCache = {
            session,
            timestamp: Date.now()
        };
    }
    
    /**
     * Get cached session if still valid
     * @returns {Object|null} - Cached session or null
     */
    getCachedSession() {
        if (!this.authStateCache) return null;
        
        const isExpired = Date.now() - this.authStateCache.timestamp > this.cacheTimeout;
        if (isExpired) {
            this.authStateCache = null;
            return null;
        }
        
        return this.authStateCache.session;
    }
    
    /**
     * Setup authentication state listener with debouncing
     */
    setupAuthStateListener() {
        if (!this.client) return;

        this.client.auth.onAuthStateChange((event, session) => {
            this.currentUser = session?.user || null;
            
            // Cache session if available
            if (session) {
                this.cacheSession(session);
            } else {
                this.authStateCache = null;
            }
            
            // Notify registered listeners with debouncing
            this.debouncedNotifyListeners(event, session);
        });
    }
    
    /**
     * Debounced notification to prevent excessive UI updates
     * @param {string} event - Authentication event
     * @param {Object} session - Session data
     */
    debouncedNotifyListeners(event, session) {
        if (this.notifyTimeout) {
            clearTimeout(this.notifyTimeout);
        }
        
        this.notifyTimeout = setTimeout(() => {
            this.authStateListeners.forEach(listener => {
                try {
                    listener(event, session);
                } catch (error) {
                    console.error('Auth state listener error:', error);
                }
            });
        }, 100);
    }
    
    /**
     * Register authentication state change listener
     * @param {Function} listener - Listener function
     */
    onAuthStateChange(listener) {
        this.authStateListeners.push(listener);
    }
    
    /**
     * Sign up with email and password
     * @param {string} email - User email
     * @param {string} password - User password
     * @param {Object} userData - Additional user data
     * @returns {Promise<Object>} - Signup result
     * @async
     */
    async signUp(email, password, userData = {}) {
        if (!this.isInitialized) {
            throw new Error('Authentication service not initialized.');
        }

        // Input validation
        if (!this.isValidEmail(email)) {
            throw new Error('Invalid email format');
        }

        if (!this.isValidPassword(password)) {
            throw new Error('Password must be at least 6 characters');
        }

        try {
            const { data, error } = await this.client.auth.signUp({
                email: email,
                password: password,
                options: {
                    data: {
                        full_name: userData.fullName || '',
                        residence_country: userData.residenceCountry || '',
                        avatar_url: userData.avatarUrl || '',
                        created_at: new Date().toISOString()
                    }
                }
            });

            if (error) {
                throw new Error(this.getErrorMessage(error));
            }

            // Email confirmation required
            if (data.user && !data.session) {
                toastManager.show('ì´ë©”ì¼ í™•ì¸ ë§í¬ë¥¼ ë°œì†¡í–ˆìŠµë‹ˆë‹¤. ì´ë©”ì¼ì„ í™•ì¸í•´ì£¼ì„¸ìš”.', 'info');
                return {
                    success: true,
                    needsEmailConfirmation: true,
                    user: data.user
                };
            }

            // Immediately signed in
            if (data.session) {
                this.currentUser = data.user;
                this.cacheSession(data.session);
                toastManager.show('íšŒì›ê°€ì…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
                return {
                    success: true,
                    needsEmailConfirmation: false,
                    user: data.user,
                    session: data.session
                };
            }

        } catch (error) {
            console.error('Signup failed:', error);
            toastManager.show(error.message, 'error');
            throw error;
        }
    }
    
    /**
     * Sign in with email and password
     * @param {string} email - User email
     * @param {string} password - User password
     * @param {boolean} remember - Remember user option
     * @returns {Promise<Object>} - Signin result
     * @async
     */
    async signIn(email, password, remember = false) {
        if (!this.isInitialized) {
            throw new Error('Authentication service not initialized.');
        }

        if (!this.client) {
            throw new Error('Supabase client not available.');
        }

        // Input validation
        if (!this.isValidEmail(email)) {
            throw new Error('Invalid email format');
        }

        try {
            const { data, error } = await this.client.auth.signInWithPassword({
                email: email,
                password: password
            });

            if (error) {
                throw new Error(this.getErrorMessage(error));
            }

            this.currentUser = data.user;
            this.cacheSession(data.session);

            toastManager.show('ë¡œê·¸ì¸ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
            return {
                success: true,
                user: data.user,
                session: data.session
            };

        } catch (error) {
            console.error('Sign in failed:', error);
            toastManager.show(error.message, 'error');
            throw error;
        }
    }
    
    /**
     * Sign out user
     * @returns {Promise<Object>} - Signout result
     * @async
     */
    async signOut() {
        if (!this.isInitialized) {
            throw new Error('Authentication service not initialized.');
        }

        try {
            const { error } = await this.client.auth.signOut();

            if (error) {
                throw new Error(this.getErrorMessage(error));
            }

            this.currentUser = null;
            this.authStateCache = null;
            
            // Redirect to login after logout
            setTimeout(() => {
                this.redirectToLogin();
            }, 1000);
            
            return {
                success: true
            };

        } catch (error) {
            console.error('Sign out failed:', error);
            toastManager.show(error.message, 'error');
            throw error;
        }
    }
    
    /**
     * Get current user
     * @returns {Object|null} - Current user or null
     */
    getCurrentUser() {
        return this.currentUser;
    }
    
    /**
     * Check if user is logged in
     * @returns {boolean} - Login status
     */
    isLoggedIn() {
        return !!this.currentUser;
    }
    
    /**
     * Validate email format
     * @param {string} email - Email to validate
     * @returns {boolean} - Whether email is valid
     */
    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
    
    /**
     * Validate password strength
     * @param {string} password - Password to validate
     * @returns {boolean} - Whether password is valid
     */
    isValidPassword(password) {
        return password && password.length >= 6;
    }
    
    /**
     * Convert Supabase error messages to Korean
     * @param {Object} error - Supabase error object
     * @returns {string} - Korean error message
     */
    getErrorMessage(error) {
        const errorMessages = {
            'Invalid login credentials': 'ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.',
            'Email not confirmed': 'ì´ë©”ì¼ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤. ì´ë©”ì¼ì„ í™•ì¸í•´ì£¼ì„¸ìš”.',
            'User already registered': 'ì´ë¯¸ ë“±ë¡ëœ ì´ë©”ì¼ì…ë‹ˆë‹¤.',
            'Password should be at least 6 characters': 'ë¹„ë°€ë²ˆí˜¸ëŠ” ìµœì†Œ 6ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.',
            'Invalid email': 'ì˜¬ë°”ë¥¸ ì´ë©”ì¼ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤.',
            'Signup requires a valid password': 'ìœ íš¨í•œ ë¹„ë°€ë²ˆí˜¸ê°€ í•„ìš”í•©ë‹ˆë‹¤.',
            'User not found': 'ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
            'Too many requests': 'ë„ˆë¬´ ë§ì€ ìš”ì²­ì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
            'Network request failed': 'ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.',
            'Invalid API key': 'API í‚¤ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.',
            'Service unavailable': 'ì„œë¹„ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.'
        };

        return errorMessages[error.message] || error.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
    }
    
    /**
     * Cleanup authentication service
     */
    cleanup() {
        this.authStateListeners = [];
        this.currentUser = null;
        this.isInitialized = false;
        this.authStateCache = null;
        
        if (this.notifyTimeout) {
            clearTimeout(this.notifyTimeout);
        }
    }
}
```

## ğŸ”’ Security Best Practices

### **Input Validation**
```javascript
/**
 * Comprehensive input validation for authentication
 */
class AuthInputValidator {
    /**
     * Validate email format and domain
     * @param {string} email - Email to validate
     * @returns {Object} - Validation result
     */
    static validateEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        const isValid = emailRegex.test(email);
        
        return {
            isValid,
            message: isValid ? '' : 'ì˜¬ë°”ë¥¸ ì´ë©”ì¼ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤.'
        };
    }
    
    /**
     * Validate password strength
     * @param {string} password - Password to validate
     * @returns {Object} - Validation result
     */
    static validatePassword(password) {
        const minLength = 6;
        const hasMinLength = password && password.length >= minLength;
        
        return {
            isValid: hasMinLength,
            message: hasMinLength ? '' : `ë¹„ë°€ë²ˆí˜¸ëŠ” ìµœì†Œ ${minLength}ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.`
        };
    }
    
    /**
     * Validate password confirmation
     * @param {string} password - Original password
     * @param {string} confirmPassword - Confirmation password
     * @returns {Object} - Validation result
     */
    static validatePasswordConfirmation(password, confirmPassword) {
        const isMatch = password === confirmPassword;
        
        return {
            isValid: isMatch,
            message: isMatch ? '' : 'ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.'
        };
    }
}
```

### **Session Security**
```javascript
/**
 * Secure session management
 */
class SecureSessionManager {
    constructor() {
        this.sessionTimeout = 30 * 60 * 1000; // 30 minutes
        this.lastActivity = Date.now();
        this.activityTimer = null;
    }
    
    /**
     * Start session timeout monitoring
     */
    startSessionMonitoring() {
        this.resetActivityTimer();
        
        // Monitor user activity
        document.addEventListener('click', () => this.updateActivity());
        document.addEventListener('keypress', () => this.updateActivity());
        document.addEventListener('scroll', () => this.updateActivity());
    }
    
    /**
     * Update last activity time
     */
    updateActivity() {
        this.lastActivity = Date.now();
        this.resetActivityTimer();
    }
    
    /**
     * Reset activity timer
     */
    resetActivityTimer() {
        if (this.activityTimer) {
            clearTimeout(this.activityTimer);
        }
        
        this.activityTimer = setTimeout(() => {
            this.handleSessionTimeout();
        }, this.sessionTimeout);
    }
    
    /**
     * Handle session timeout
     */
    handleSessionTimeout() {
        console.log('Session timeout - logging out user');
        authService.signOut();
    }
}
```

## ğŸ¨ UI/UX Guidelines

### **Authentication Form Design**
```html
<!-- Login Form with proper accessibility -->
<form class="login-form" id="login-form" novalidate>
    <div class="form-group">
        <label for="email" class="form-label">
            ì´ë©”ì¼
            <span class="required-indicator" aria-label="í•„ìˆ˜ í•­ëª©">*</span>
        </label>
        <input 
            type="email" 
            id="email" 
            name="email" 
            class="form-input" 
            placeholder="your@email.com"
            autocomplete="email"
            required
            aria-describedby="email-error"
        >
        <div id="email-error" class="form-error" role="alert" aria-live="polite"></div>
    </div>
    
    <div class="form-group">
        <label for="password" class="form-label">
            ë¹„ë°€ë²ˆí˜¸
            <span class="required-indicator" aria-label="í•„ìˆ˜ í•­ëª©">*</span>
        </label>
        <input 
            type="password" 
            id="password" 
            name="password" 
            class="form-input" 
            placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
            autocomplete="current-password"
            required
            aria-describedby="password-error"
        >
        <div id="password-error" class="form-error" role="alert" aria-live="polite"></div>
    </div>
    
    <div class="form-options">
        <label class="checkbox-label" for="remember">
            <input type="checkbox" id="remember" name="remember">
            <span class="checkmark"></span>
            ë¡œê·¸ì¸ ìƒíƒœ ìœ ì§€
        </label>
        <a href="#" class="forgot-password" aria-label="ë¹„ë°€ë²ˆí˜¸ ì°¾ê¸°">ë¹„ë°€ë²ˆí˜¸ ì°¾ê¸°</a>
    </div>
    
    <button type="submit" class="login-btn" id="login-btn" aria-describedby="login-status">
        ë¡œê·¸ì¸
    </button>
    <div id="login-status" class="form-status" role="status" aria-live="polite"></div>
</form>
```

### **Loading States**
```css
/* Authentication loading states */
.login-btn.loading {
    position: relative;
    color: transparent;
}

.login-btn.loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin: -10px 0 0 -10px;
    border: 2px solid transparent;
    border-top: 2px solid currentColor;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Form validation states */
.form-input.error {
    border-color: var(--error-color);
    box-shadow: 0 0 0 2px rgba(var(--error-color-rgb), 0.2);
}

.form-input.success {
    border-color: var(--success-color);
    box-shadow: 0 0 0 2px rgba(var(--success-color-rgb), 0.2);
}

.form-error {
    color: var(--error-color);
    font-size: var(--font-sm);
    margin-top: var(--spacing-xs);
    min-height: 1.2em;
}
```

## ğŸ“Š Performance Optimization

### **Authentication Performance Checklist**
- âœ… Cache authentication state to reduce API calls
- âœ… Debounce authentication state changes
- âœ… Batch UI updates during authentication flows
- âœ… Use requestAnimationFrame for smooth transitions
- âœ… Implement proper session cleanup
- âœ… Optimize authentication form validation
- âœ… Use efficient error handling patterns
- âœ… Implement session timeout monitoring
- âœ… Cache user data appropriately
- âœ… Minimize authentication-related DOM manipulation

### **Memory Management**
```javascript
/**
 * Authentication memory management
 */
class AuthMemoryManager {
    constructor() {
        this.cleanupTasks = [];
        this.eventListeners = new Map();
    }
    
    /**
     * Register cleanup task
     * @param {Function} task - Cleanup task
     */
    registerCleanup(task) {
        this.cleanupTasks.push(task);
    }
    
    /**
     * Track event listener for cleanup
     * @param {HTMLElement} element - Element with listener
     * @param {string} event - Event type
     * @param {Function} handler - Event handler
     */
    trackEventListener(element, event, handler) {
        if (!this.eventListeners.has(element)) {
            this.eventListeners.set(element, []);
        }
        
        this.eventListeners.get(element).push({ event, handler });
    }
    
    /**
     * Cleanup all tracked resources
     */
    cleanup() {
        // Execute cleanup tasks
        this.cleanupTasks.forEach(task => {
            try {
                task();
            } catch (error) {
                console.error('Cleanup task failed:', error);
            }
        });
        
        // Remove event listeners
        this.eventListeners.forEach((listeners, element) => {
            listeners.forEach(({ event, handler }) => {
                element.removeEventListener(event, handler);
            });
        });
        
        this.cleanupTasks = [];
        this.eventListeners.clear();
    }
}
```

## ğŸ§ª Testing Guidelines

### **Authentication Testing Pattern**
```javascript
/**
 * Authentication testing utilities
 */
class AuthTestHelper {
    /**
     * Mock authentication service for testing
     */
    static createMockAuthService() {
        return {
            isLoggedIn: () => false,
            getCurrentUser: () => null,
            signIn: jest.fn(),
            signUp: jest.fn(),
            signOut: jest.fn(),
            onAuthStateChange: jest.fn()
        };
    }
    
    /**
     * Create test authentication manager
     */
    static createTestAuthManager() {
        const container = document.createElement('div');
        container.innerHTML = `
            <div id="login-screen">
                <form id="login-form">
                    <input id="email" type="email">
                    <input id="password" type="password">
                    <button id="login-btn" type="submit">ë¡œê·¸ì¸</button>
                </form>
            </div>
            <div id="main-app" class="hidden">Main App</div>
        `;
        
        document.body.appendChild(container);
        
        return {
            container,
            cleanup: () => {
                document.body.removeChild(container);
            }
        };
    }
}
```

## ğŸš€ Best Practices Summary

### **DO's**
âœ… Always validate user input on both client and server
âœ… Use secure session management with proper token handling
âœ… Implement proper error handling without exposing sensitive information
âœ… Provide clear, Korean error messages for users
âœ… Cache authentication state to reduce API calls
âœ… Debounce authentication state changes
âœ… Implement proper cleanup of authentication resources
âœ… Use consistent authentication patterns across the application
âœ… Document authentication flows clearly
âœ… Test authentication flows thoroughly

### **DON'Ts**
âŒ Don't store sensitive information in localStorage
âŒ Don't expose authentication errors to users
âŒ Don't skip input validation
âŒ Don't ignore authentication state cleanup
âŒ Don't use synchronous operations for authentication
âŒ Don't skip error handling in authentication flows
âŒ Don't ignore accessibility in authentication forms
âŒ Don't skip testing authentication functionality
âŒ Don't hardcode authentication credentials
âŒ Don't ignore session timeout management

## ğŸ”® Future Enhancements

### **Phase 1: Enhanced Security**
- Multi-factor authentication (MFA)
- Biometric authentication support
- Advanced session management
- Security audit logging

### **Phase 2: Performance Improvements**
- Advanced caching strategies
- Authentication state persistence
- Optimized API calls
- Real-time authentication updates

### **Phase 3: User Experience**
- Social authentication providers
- Remember device functionality
- Advanced password policies
- Authentication analytics

---

**This authentication system ensures TravelLog maintains secure, performant, and user-friendly authentication while following industry best practices and security guidelines.**