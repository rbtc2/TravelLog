---
globs: *.js,*.html,*.css
description: TravelLog authentication system guidelines and security best practices
---

# 🔐 TravelLog Authentication Rules

## 📋 Overview
This document outlines authentication system guidelines, security best practices, and development patterns for the TravelLog project using Supabase authentication.

## 🎯 Core Authentication Principles

### 1. **Security First**
- Always validate user input on both client and server
- Use secure session management with proper token handling
- Implement proper error handling without exposing sensitive information
- Follow OWASP security guidelines for authentication

### 2. **User Experience**
- Provide clear, Korean error messages for users
- Implement smooth authentication state transitions
- Handle loading states gracefully
- Support offline authentication state persistence

### 3. **Performance**
- Cache authentication state to reduce API calls
- Debounce authentication state changes
- Batch UI updates during authentication flows
- Optimize session management

### 4. **Maintainability**
- Use consistent authentication patterns across the application
- Implement proper error handling and logging
- Follow established module patterns
- Document authentication flows clearly

## 🏗️ Authentication Architecture

### **Three-Tier Authentication System**

#### **Level 1: AuthManager (UI Layer)**
- Manages authentication UI components
- Handles user interactions and form validation
- Manages authentication state transitions
- Provides user feedback and error messages

#### **Level 2: AuthService (Business Logic Layer)**
- Handles Supabase API calls
- Manages authentication state
- Implements security policies
- Provides authentication utilities

#### **Level 3: SupabaseConfig (Configuration Layer)**
- Manages Supabase client configuration
- Handles environment-specific settings
- Provides connection management

## 🔧 Authentication Patterns

### **Authentication Manager Pattern**
```javascript
/**
 * Authentication Manager - UI Management Layer
 * Handles all authentication-related UI interactions
 */
class AuthManager {
    constructor() {
        this.isInitialized = false;
        this.isLoggingOut = false;
        this.isHandlingAuthSuccess = false;
        this.authStateListenerSetup = false;
        this.currentView = 'login'; // 'login' | 'signup' | 'forgot-password'
        
        // UI elements
        this.loginScreen = null;
        this.loginForm = null;
        this.signupForm = null;
        this.forgotPasswordForm = null;
        this.demoBtn = null;
        this.countrySelector = null;
        
        this.init();
    }
    
    /**
     * Initialize authentication manager
     * @async
     */
    async init() {
        try {
            // Initialize auth service
            await authService.initialize();
            
            // Get DOM elements
            this.loginScreen = document.getElementById('login-screen');
            this.loginForm = document.getElementById('login-form');
            this.demoBtn = document.getElementById('demo-btn');
            
            // Bind events (only once)
            if (!this.isInitialized) {
                this.bindEvents();
                this.setupAuthStateListener();
            }
            
            // Check current auth state
            if (authService.isLoggedIn()) {
                this.handleAuthSuccess();
            } else {
                this.showLoginView();
            }
            
            this.isInitialized = true;
        } catch (error) {
            console.error('Auth manager initialization failed:', error);
            this.showError('Authentication system could not be initialized.');
        }
    }
    
    /**
     * Bind event listeners with proper cleanup
     */
    bindEvents() {
        // Remove existing listeners to prevent duplicates
        if (this.loginForm) {
            this.loginForm.removeEventListener('submit', this.handleLoginSubmit);
        }
        
        // Login form submission
        if (this.loginForm) {
            this.handleLoginSubmit = (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.handleLogin();
            };
            this.loginForm.addEventListener('submit', this.handleLoginSubmit);
        }
        
        // Other event bindings...
    }
    
    /**
     * Setup authentication state listener
     */
    setupAuthStateListener() {
        if (this.authStateListenerSetup) return;
        this.authStateListenerSetup = true;

        authService.onAuthStateChange((event, session) => {
            if (event === 'SIGNED_IN' && session) {
                this.handleAuthSuccess();
            } else if (event === 'SIGNED_OUT') {
                this.handleAuthLogout();
            }
        });
    }
    
    /**
     * Handle login process with validation
     * @async
     */
    async handleLogin() {
        const email = document.getElementById('email').value;
        const password = document.getElementById('password').value;
        const remember = document.getElementById('remember').checked;

        // Input validation
        if (!email || !password) {
            toastManager.show('이메일과 비밀번호를 입력해주세요.', 'error');
            return;
        }

        // Email format validation
        if (!this.isValidEmail(email)) {
            toastManager.show('올바른 이메일 형식이 아닙니다.', 'error');
            return;
        }

        try {
            this.setLoadingState(true);
            
            const result = await authService.signIn(email, password, remember);
            
            if (result && result.success) {
                this.handleAuthSuccess();
            } else {
                toastManager.show('로그인에 실패했습니다.', 'error');
            }
            
        } catch (error) {
            console.error('Login failed:', error);
            // Error messages are handled by authService
        } finally {
            this.setLoadingState(false);
        }
    }
    
    /**
     * Validate email format
     * @param {string} email - Email to validate
     * @returns {boolean} - Whether email is valid
     */
    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
    
    /**
     * Handle authentication success
     */
    handleAuthSuccess() {
        if (this.isHandlingAuthSuccess) return;
        this.isHandlingAuthSuccess = true;

        // Hide login screen
        if (this.loginScreen) {
            this.loginScreen.style.display = 'none';
        }
        
        // Show main app
        const mainApp = document.getElementById('main-app');
        if (mainApp) {
            mainApp.classList.remove('hidden');
        }
        
        // Notify app manager
        if (window.appManager) {
            window.appManager.loginSuccess();
        }

        // Reset state
        setTimeout(() => {
            this.isHandlingAuthSuccess = false;
        }, 1000);
    }
}
```

### **Authentication Service Pattern**
```javascript
/**
 * Authentication Service - Business Logic Layer
 * Handles all authentication business logic and Supabase API calls
 */
class AuthService {
    constructor() {
        this.client = null;
        this.currentUser = null;
        this.isInitialized = false;
        this.isRedirecting = false;
        this.authStateListeners = [];
        
        // Performance optimization
        this.authStateCache = null;
        this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
    }
    
    /**
     * Initialize authentication service
     * @async
     */
    async initialize() {
        try {
            this.client = await initializeSupabase();
            this.isInitialized = true;
            
            // Check current session
            await this.checkCurrentSession();
            
            // Setup auth state listener
            this.setupAuthStateListener();
            
            console.log('Authentication service initialized.');
        } catch (error) {
            console.error('Auth service initialization failed:', error);
            throw error;
        }
    }
    
    /**
     * Check current session with caching
     * @async
     */
    async checkCurrentSession() {
        if (!this.client) return;

        // Check cache first
        const cachedSession = this.getCachedSession();
        if (cachedSession) {
            this.currentUser = cachedSession.user;
            return;
        }

        try {
            const { data: { session }, error } = await this.client.auth.getSession();
            
            if (error) {
                console.error('Session check failed:', error);
                return;
            }

            if (session) {
                this.currentUser = session.user;
                this.cacheSession(session);
                console.log('Current user:', this.currentUser.email);
            }
        } catch (error) {
            console.error('Session check error:', error);
        }
    }
    
    /**
     * Cache session data for performance
     * @param {Object} session - Session data to cache
     */
    cacheSession(session) {
        this.authStateCache = {
            session,
            timestamp: Date.now()
        };
    }
    
    /**
     * Get cached session if still valid
     * @returns {Object|null} - Cached session or null
     */
    getCachedSession() {
        if (!this.authStateCache) return null;
        
        const isExpired = Date.now() - this.authStateCache.timestamp > this.cacheTimeout;
        if (isExpired) {
            this.authStateCache = null;
            return null;
        }
        
        return this.authStateCache.session;
    }
    
    /**
     * Setup authentication state listener with debouncing
     */
    setupAuthStateListener() {
        if (!this.client) return;

        this.client.auth.onAuthStateChange((event, session) => {
            this.currentUser = session?.user || null;
            
            // Cache session if available
            if (session) {
                this.cacheSession(session);
            } else {
                this.authStateCache = null;
            }
            
            // Notify registered listeners with debouncing
            this.debouncedNotifyListeners(event, session);
        });
    }
    
    /**
     * Debounced notification to prevent excessive UI updates
     * @param {string} event - Authentication event
     * @param {Object} session - Session data
     */
    debouncedNotifyListeners(event, session) {
        if (this.notifyTimeout) {
            clearTimeout(this.notifyTimeout);
        }
        
        this.notifyTimeout = setTimeout(() => {
            this.authStateListeners.forEach(listener => {
                try {
                    listener(event, session);
                } catch (error) {
                    console.error('Auth state listener error:', error);
                }
            });
        }, 100);
    }
    
    /**
     * Register authentication state change listener
     * @param {Function} listener - Listener function
     */
    onAuthStateChange(listener) {
        this.authStateListeners.push(listener);
    }
    
    /**
     * Sign up with email and password
     * @param {string} email - User email
     * @param {string} password - User password
     * @param {Object} userData - Additional user data
     * @returns {Promise<Object>} - Signup result
     * @async
     */
    async signUp(email, password, userData = {}) {
        if (!this.isInitialized) {
            throw new Error('Authentication service not initialized.');
        }

        // Input validation
        if (!this.isValidEmail(email)) {
            throw new Error('Invalid email format');
        }

        if (!this.isValidPassword(password)) {
            throw new Error('Password must be at least 6 characters');
        }

        try {
            const { data, error } = await this.client.auth.signUp({
                email: email,
                password: password,
                options: {
                    data: {
                        full_name: userData.fullName || '',
                        residence_country: userData.residenceCountry || '',
                        avatar_url: userData.avatarUrl || '',
                        created_at: new Date().toISOString()
                    }
                }
            });

            if (error) {
                throw new Error(this.getErrorMessage(error));
            }

            // Email confirmation required
            if (data.user && !data.session) {
                toastManager.show('이메일 확인 링크를 발송했습니다. 이메일을 확인해주세요.', 'info');
                return {
                    success: true,
                    needsEmailConfirmation: true,
                    user: data.user
                };
            }

            // Immediately signed in
            if (data.session) {
                this.currentUser = data.user;
                this.cacheSession(data.session);
                toastManager.show('회원가입이 완료되었습니다!', 'success');
                return {
                    success: true,
                    needsEmailConfirmation: false,
                    user: data.user,
                    session: data.session
                };
            }

        } catch (error) {
            console.error('Signup failed:', error);
            toastManager.show(error.message, 'error');
            throw error;
        }
    }
    
    /**
     * Sign in with email and password
     * @param {string} email - User email
     * @param {string} password - User password
     * @param {boolean} remember - Remember user option
     * @returns {Promise<Object>} - Signin result
     * @async
     */
    async signIn(email, password, remember = false) {
        if (!this.isInitialized) {
            throw new Error('Authentication service not initialized.');
        }

        if (!this.client) {
            throw new Error('Supabase client not available.');
        }

        // Input validation
        if (!this.isValidEmail(email)) {
            throw new Error('Invalid email format');
        }

        try {
            const { data, error } = await this.client.auth.signInWithPassword({
                email: email,
                password: password
            });

            if (error) {
                throw new Error(this.getErrorMessage(error));
            }

            this.currentUser = data.user;
            this.cacheSession(data.session);

            toastManager.show('로그인되었습니다!', 'success');
            return {
                success: true,
                user: data.user,
                session: data.session
            };

        } catch (error) {
            console.error('Sign in failed:', error);
            toastManager.show(error.message, 'error');
            throw error;
        }
    }
    
    /**
     * Sign out user
     * @returns {Promise<Object>} - Signout result
     * @async
     */
    async signOut() {
        if (!this.isInitialized) {
            throw new Error('Authentication service not initialized.');
        }

        try {
            const { error } = await this.client.auth.signOut();

            if (error) {
                throw new Error(this.getErrorMessage(error));
            }

            this.currentUser = null;
            this.authStateCache = null;
            
            // Redirect to login after logout
            setTimeout(() => {
                this.redirectToLogin();
            }, 1000);
            
            return {
                success: true
            };

        } catch (error) {
            console.error('Sign out failed:', error);
            toastManager.show(error.message, 'error');
            throw error;
        }
    }
    
    /**
     * Get current user
     * @returns {Object|null} - Current user or null
     */
    getCurrentUser() {
        return this.currentUser;
    }
    
    /**
     * Check if user is logged in
     * @returns {boolean} - Login status
     */
    isLoggedIn() {
        return !!this.currentUser;
    }
    
    /**
     * Validate email format
     * @param {string} email - Email to validate
     * @returns {boolean} - Whether email is valid
     */
    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
    
    /**
     * Validate password strength
     * @param {string} password - Password to validate
     * @returns {boolean} - Whether password is valid
     */
    isValidPassword(password) {
        return password && password.length >= 6;
    }
    
    /**
     * Convert Supabase error messages to Korean
     * @param {Object} error - Supabase error object
     * @returns {string} - Korean error message
     */
    getErrorMessage(error) {
        const errorMessages = {
            'Invalid login credentials': '이메일 또는 비밀번호가 올바르지 않습니다.',
            'Email not confirmed': '이메일 인증이 필요합니다. 이메일을 확인해주세요.',
            'User already registered': '이미 등록된 이메일입니다.',
            'Password should be at least 6 characters': '비밀번호는 최소 6자 이상이어야 합니다.',
            'Invalid email': '올바른 이메일 형식이 아닙니다.',
            'Signup requires a valid password': '유효한 비밀번호가 필요합니다.',
            'User not found': '사용자를 찾을 수 없습니다.',
            'Too many requests': '너무 많은 요청이 발생했습니다. 잠시 후 다시 시도해주세요.',
            'Network request failed': '네트워크 연결을 확인해주세요.',
            'Invalid API key': 'API 키가 유효하지 않습니다.',
            'Service unavailable': '서비스를 사용할 수 없습니다. 잠시 후 다시 시도해주세요.'
        };

        return errorMessages[error.message] || error.message || '알 수 없는 오류가 발생했습니다.';
    }
    
    /**
     * Cleanup authentication service
     */
    cleanup() {
        this.authStateListeners = [];
        this.currentUser = null;
        this.isInitialized = false;
        this.authStateCache = null;
        
        if (this.notifyTimeout) {
            clearTimeout(this.notifyTimeout);
        }
    }
}
```

## 🔒 Security Best Practices

### **Input Validation**
```javascript
/**
 * Comprehensive input validation for authentication
 */
class AuthInputValidator {
    /**
     * Validate email format and domain
     * @param {string} email - Email to validate
     * @returns {Object} - Validation result
     */
    static validateEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        const isValid = emailRegex.test(email);
        
        return {
            isValid,
            message: isValid ? '' : '올바른 이메일 형식이 아닙니다.'
        };
    }
    
    /**
     * Validate password strength
     * @param {string} password - Password to validate
     * @returns {Object} - Validation result
     */
    static validatePassword(password) {
        const minLength = 6;
        const hasMinLength = password && password.length >= minLength;
        
        return {
            isValid: hasMinLength,
            message: hasMinLength ? '' : `비밀번호는 최소 ${minLength}자 이상이어야 합니다.`
        };
    }
    
    /**
     * Validate password confirmation
     * @param {string} password - Original password
     * @param {string} confirmPassword - Confirmation password
     * @returns {Object} - Validation result
     */
    static validatePasswordConfirmation(password, confirmPassword) {
        const isMatch = password === confirmPassword;
        
        return {
            isValid: isMatch,
            message: isMatch ? '' : '비밀번호가 일치하지 않습니다.'
        };
    }
}
```

### **Session Security**
```javascript
/**
 * Secure session management
 */
class SecureSessionManager {
    constructor() {
        this.sessionTimeout = 30 * 60 * 1000; // 30 minutes
        this.lastActivity = Date.now();
        this.activityTimer = null;
    }
    
    /**
     * Start session timeout monitoring
     */
    startSessionMonitoring() {
        this.resetActivityTimer();
        
        // Monitor user activity
        document.addEventListener('click', () => this.updateActivity());
        document.addEventListener('keypress', () => this.updateActivity());
        document.addEventListener('scroll', () => this.updateActivity());
    }
    
    /**
     * Update last activity time
     */
    updateActivity() {
        this.lastActivity = Date.now();
        this.resetActivityTimer();
    }
    
    /**
     * Reset activity timer
     */
    resetActivityTimer() {
        if (this.activityTimer) {
            clearTimeout(this.activityTimer);
        }
        
        this.activityTimer = setTimeout(() => {
            this.handleSessionTimeout();
        }, this.sessionTimeout);
    }
    
    /**
     * Handle session timeout
     */
    handleSessionTimeout() {
        console.log('Session timeout - logging out user');
        authService.signOut();
    }
}
```

## 🎨 UI/UX Guidelines

### **Authentication Form Design**
```html
<!-- Login Form with proper accessibility -->
<form class="login-form" id="login-form" novalidate>
    <div class="form-group">
        <label for="email" class="form-label">
            이메일
            <span class="required-indicator" aria-label="필수 항목">*</span>
        </label>
        <input 
            type="email" 
            id="email" 
            name="email" 
            class="form-input" 
            placeholder="your@email.com"
            autocomplete="email"
            required
            aria-describedby="email-error"
        >
        <div id="email-error" class="form-error" role="alert" aria-live="polite"></div>
    </div>
    
    <div class="form-group">
        <label for="password" class="form-label">
            비밀번호
            <span class="required-indicator" aria-label="필수 항목">*</span>
        </label>
        <input 
            type="password" 
            id="password" 
            name="password" 
            class="form-input" 
            placeholder="••••••••"
            autocomplete="current-password"
            required
            aria-describedby="password-error"
        >
        <div id="password-error" class="form-error" role="alert" aria-live="polite"></div>
    </div>
    
    <div class="form-options">
        <label class="checkbox-label" for="remember">
            <input type="checkbox" id="remember" name="remember">
            <span class="checkmark"></span>
            로그인 상태 유지
        </label>
        <a href="#" class="forgot-password" aria-label="비밀번호 찾기">비밀번호 찾기</a>
    </div>
    
    <button type="submit" class="login-btn" id="login-btn" aria-describedby="login-status">
        로그인
    </button>
    <div id="login-status" class="form-status" role="status" aria-live="polite"></div>
</form>
```

### **Loading States**
```css
/* Authentication loading states */
.login-btn.loading {
    position: relative;
    color: transparent;
}

.login-btn.loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin: -10px 0 0 -10px;
    border: 2px solid transparent;
    border-top: 2px solid currentColor;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Form validation states */
.form-input.error {
    border-color: var(--error-color);
    box-shadow: 0 0 0 2px rgba(var(--error-color-rgb), 0.2);
}

.form-input.success {
    border-color: var(--success-color);
    box-shadow: 0 0 0 2px rgba(var(--success-color-rgb), 0.2);
}

.form-error {
    color: var(--error-color);
    font-size: var(--font-sm);
    margin-top: var(--spacing-xs);
    min-height: 1.2em;
}
```

## 📊 Performance Optimization

### **Authentication Performance Checklist**
- ✅ Cache authentication state to reduce API calls
- ✅ Debounce authentication state changes
- ✅ Batch UI updates during authentication flows
- ✅ Use requestAnimationFrame for smooth transitions
- ✅ Implement proper session cleanup
- ✅ Optimize authentication form validation
- ✅ Use efficient error handling patterns
- ✅ Implement session timeout monitoring
- ✅ Cache user data appropriately
- ✅ Minimize authentication-related DOM manipulation

### **Memory Management**
```javascript
/**
 * Authentication memory management
 */
class AuthMemoryManager {
    constructor() {
        this.cleanupTasks = [];
        this.eventListeners = new Map();
    }
    
    /**
     * Register cleanup task
     * @param {Function} task - Cleanup task
     */
    registerCleanup(task) {
        this.cleanupTasks.push(task);
    }
    
    /**
     * Track event listener for cleanup
     * @param {HTMLElement} element - Element with listener
     * @param {string} event - Event type
     * @param {Function} handler - Event handler
     */
    trackEventListener(element, event, handler) {
        if (!this.eventListeners.has(element)) {
            this.eventListeners.set(element, []);
        }
        
        this.eventListeners.get(element).push({ event, handler });
    }
    
    /**
     * Cleanup all tracked resources
     */
    cleanup() {
        // Execute cleanup tasks
        this.cleanupTasks.forEach(task => {
            try {
                task();
            } catch (error) {
                console.error('Cleanup task failed:', error);
            }
        });
        
        // Remove event listeners
        this.eventListeners.forEach((listeners, element) => {
            listeners.forEach(({ event, handler }) => {
                element.removeEventListener(event, handler);
            });
        });
        
        this.cleanupTasks = [];
        this.eventListeners.clear();
    }
}
```

## 🧪 Testing Guidelines

### **Authentication Testing Pattern**
```javascript
/**
 * Authentication testing utilities
 */
class AuthTestHelper {
    /**
     * Mock authentication service for testing
     */
    static createMockAuthService() {
        return {
            isLoggedIn: () => false,
            getCurrentUser: () => null,
            signIn: jest.fn(),
            signUp: jest.fn(),
            signOut: jest.fn(),
            onAuthStateChange: jest.fn()
        };
    }
    
    /**
     * Create test authentication manager
     */
    static createTestAuthManager() {
        const container = document.createElement('div');
        container.innerHTML = `
            <div id="login-screen">
                <form id="login-form">
                    <input id="email" type="email">
                    <input id="password" type="password">
                    <button id="login-btn" type="submit">로그인</button>
                </form>
            </div>
            <div id="main-app" class="hidden">Main App</div>
        `;
        
        document.body.appendChild(container);
        
        return {
            container,
            cleanup: () => {
                document.body.removeChild(container);
            }
        };
    }
}
```

## 🚀 Best Practices Summary

### **DO's**
✅ Always validate user input on both client and server
✅ Use secure session management with proper token handling
✅ Implement proper error handling without exposing sensitive information
✅ Provide clear, Korean error messages for users
✅ Cache authentication state to reduce API calls
✅ Debounce authentication state changes
✅ Implement proper cleanup of authentication resources
✅ Use consistent authentication patterns across the application
✅ Document authentication flows clearly
✅ Test authentication flows thoroughly

### **DON'Ts**
❌ Don't store sensitive information in localStorage
❌ Don't expose authentication errors to users
❌ Don't skip input validation
❌ Don't ignore authentication state cleanup
❌ Don't use synchronous operations for authentication
❌ Don't skip error handling in authentication flows
❌ Don't ignore accessibility in authentication forms
❌ Don't skip testing authentication functionality
❌ Don't hardcode authentication credentials
❌ Don't ignore session timeout management

## 🔮 Future Enhancements

### **Phase 1: Enhanced Security**
- Multi-factor authentication (MFA)
- Biometric authentication support
- Advanced session management
- Security audit logging

### **Phase 2: Performance Improvements**
- Advanced caching strategies
- Authentication state persistence
- Optimized API calls
- Real-time authentication updates

### **Phase 3: User Experience**
- Social authentication providers
- Remember device functionality
- Advanced password policies
- Authentication analytics

---

**This authentication system ensures TravelLog maintains secure, performant, and user-friendly authentication while following industry best practices and security guidelines.**